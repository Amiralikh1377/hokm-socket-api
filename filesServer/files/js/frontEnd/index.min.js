(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Player = require("./Player");

var _Player2 = _interopRequireDefault(_Player);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import $ from './jquery-2.0.3.min'

var Ai = function Ai(id, name) {
    _Player2.default.call(this, id, name);
};

Ai.prototype = Object.create(_Player2.default.prototype);

Ai.prototype.prepareTransfer = function () {
    var selected = [],
        cards = [];
    while (selected.length < 3) {
        var s = Math.floor(Math.random() * this.row.cards.length);
        if (selected.indexOf(s) === -1) {
            selected.push(s);
        }
    }
    for (var i = 0; i < 3; i++) {
        cards.push(this.row.cards[selected[i]]);
    }
    this.selected = cards;
    return $.Deferred().resolve();
};

Ai.prototype.confirmTransfer = function () {
    return this.brain.confirmCards();
};

Ai.prototype.transferTo = function (other) {
    var selected = this.selected;
    _Player2.default.prototype.transferTo.call(this, other);
    this.brain.watch({
        type: "in",
        player: other,
        cards: selected
    });
};

Ai.prototype.watch = function (info) {
    this.brain.watch(info);
};

Ai.prototype.decide = function (validCards, boardCards, boardPlayers, scores) {
    return this.brain.decide(validCards, boardCards, boardPlayers, scores).then(function (c) {
        return this.row.cards[c];
    }.bind(this));
};
Ai.prototype.inSethakem = function (val) {
    this.row.flipped = !val;
    if (!val) this.row.display = null;
};

exports.default = Ai;

},{"./Player":7}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Brain = require("./Brain");

var _Brain2 = _interopRequireDefault(_Brain);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AsyncBrain = function AsyncBrain(user, brainName, options) {
    _Brain2.default.call(this, user);
    var worker = this.worker = new Worker("../files/js/BrainWorker.js");
    this.initDefer = $.Deferred();
    var self = this;
    this.worker.onmessage = function (e) {
        if (e.data.type === "decision") {
            self.curDefer.resolve(e.data.result);
            self.curDefer = null;
        } else if (e.data.type === "loaded") {
            worker.postMessage({
                type: "ini",
                userId: user.id,
                brain: brainName,
                options: options
            });
        } else if (e.data.type === "ini-ed") {
            self.initDefer.resolve();
        } else if (e.data.type === "confirmed") {
            self.confirmDefer.resolve();
        }
    };
};

AsyncBrain.prototype = Object.create(_Brain2.default.prototype);

AsyncBrain.prototype.terminate = function () {
    this.initDefer && this.initDefer.reject();
    this.curDefer && this.curDefer.reject();
    this.confirmDefer && this.confirmDefer.reject();
};

AsyncBrain.prototype.init = function () {
    return this.initDefer;
};

AsyncBrain.prototype.watch = function (info) {
    var tinfo = {
        type: info.type,
        player: info.player.id
    };
    if (info.cards) {
        tinfo.cards = info.cards.map(function (c) {
            return c.id;
        });
    }
    if (info.card) {
        tinfo.card = info.card.id;
    }
    if (info.curSuit) {
        tinfo.curSuit = info.curSuit;
    }
    this.worker.postMessage({
        type: "watch",
        params: tinfo
    });
};

AsyncBrain.prototype.confirmCards = function () {
    this.worker.postMessage({
        type: "confirm",
        cards: this.user.row.cards.map(function (c) {
            return c.id;
        })
    });
    this.confirmDefer = $.Deferred();
    return this.confirmDefer;
};

AsyncBrain.prototype.decide = function (validCards, boardCards, boardPlayers, scores) {
    this.worker.postMessage({
        type: "decide",
        params: {
            validCards: validCards.map(function (c) {
                return { id: c.id, ind: c.ind };
            }),
            boardCards: boardCards.map(function (c) {
                return c.id;
            }),
            boardPlayers: boardPlayers.map(function (c) {
                return c.id;
            }),
            scores: scores
        }
    });
    this.curDefer = $.Deferred();
    return this.curDefer;
};

exports.default = AsyncBrain;

},{"./Brain":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
var Brain = function Brain(user) {
    this.user = user;
    this.playerInfo = [[], [], [], []];
};

Brain.prototype.watch = function (info) {};

Brain.prototype.confirmCards = function () {
    return {
        done: function done(cb) {
            cb();
        }
    };
};

Brain.prototype.init = function () {
    return $.Deferred().resolve();
};

Brain.prototype.terminate = function () {};

exports.default = Brain;

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _domBinding = require('./domBinding');

var _domBinding2 = _interopRequireDefault(_domBinding);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var suits = ['spade', 'heart', 'club', 'diamond'];
var Card = function Card(id) {
    this.id = id;
    this.num = id % 13 + 1;
    this.suit = id % 4;
    this.flipped = true;

    var acutualNum = this.num + 1;
    var numtext = acutualNum + '';
    if (acutualNum > 10) {
        numtext = {
            11: 'J',
            12: 'Q',
            13: 'K',
            14: 'A'
        }[acutualNum];
    }
    this.display = _domBinding2.default.createCardDisplay(numtext, this.suit);
    this.display.onClick = this.shift.bind(this);
};

Card.suits = suits;

Card.prototype.adjustPos = function (noUpdate) {
    if (!noUpdate) this.pos = this.parent.getPosFor(this.ind, this);
    this.display.adjustPos(this.pos);
};

Card.prototype.shift = function () {

    if (!this.display.isSelectable()) return;
    if (!this.parent.curShifted) return;
    if (this.parent.curShifted.indexOf(this) !== -1) {
        this.parent.removeShift(this);
    } else {
        //delete this
        this.parent.addShift(this);
    }
};

Card.prototype.out = function () {
    this.display.out();
};

exports.default = Card;

},{"./domBinding":17}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var logs = [];
var Debug = {};
Debug.log = function (title, mess) {
    if ((typeof mess === "undefined" ? "undefined" : _typeof(mess)) === 'object') mess = JSON.stringify(mess);
    logs.push({ title: title, mess: mess });
};
Debug.show = function () {
    var wnd = window.open("about:blank", "", "_blank");
    logs.forEach(function (l) {
        var s = window.document.createElement("div");
        s.innerHTML = l.title + "----|----" + l.mess;
        wnd.document.body.appendChild(s);
    });
};
exports.default = Debug;

},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Player = require('./Player');

var _Player2 = _interopRequireDefault(_Player);

var _ui = require('./ui');

var _ui2 = _interopRequireDefault(_ui);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Human = function Human(id, name) {

    _Player2.default.call(this, id, name);
    this.row.flipped = false;
    this.display.setHuman(true);
};
//import $ from 'jquery-2.0.3.min'


Human.prototype = Object.create(_Player2.default.prototype);

Human.prototype.takeIn = function (cards) {
    _Player2.default.prototype.takeIn.call(this, cards);
    this.row.setSelected(cards);
};

Human.prototype.decide = function (validCards) {
    validCards.forEach(function (c) {
        c.display.setSelectable(true);
    });
    if (validCards.length === 1 && validCards[0].id === 26) {
        _ui2.default.showMessage('Please start with 2 of Clubs.');
    }
    var d = $.Deferred();
    var row = this.row;
    _ui2.default.buttonClickOnce(function () {
        _ui2.default.hideMessage();
        _ui2.default.hideButton();
        validCards.forEach(function (c) {
            c.display.setSelectable(false);
        });
        d.resolve(row.getSelected()[0]);
    });
    return d;
};

Human.prototype.confirmTransfer = function () {
    _ui2.default.showButton("Confirm");
    _ui2.default.hideArrow();
    _ui2.default.hideMessage();
    var d = $.Deferred();
    _ui2.default.buttonClickOnce(function () {
        this.doneTransfer();
        d.resolve();
    }.bind(this));
    return d;
};

Human.prototype.doneTransfer = function () {
    this.row.curShifted = [];
    this.row.adjustPos();
    _ui2.default.hideButton();
};

Human.prototype.initForNewRound = function () {
    _Player2.default.prototype.initForNewRound.call(this);
    this.row.curShifted = [];
};

Human.prototype.prepareTransfer = function (dir) {
    _ui2.default.showPassingScreen(dir);
    this.row.cards.forEach(function (c) {
        c.display.setSelectable(true);
    });
    this.row.maxShift = 3;
    var d = $.Deferred();
    var row = this.row;
    _ui2.default.arrowClickOnce(function () {
        this.selected = row.getSelected();
        this.row.maxShift = 1;
        this.row.cards.forEach(function (c) {
            c.display.setSelectable(false);
        });
        d.resolve();
    }.bind(this));

    return d;
};

Human.prototype.rowSelected = function () {
    if (this.row.maxShift === 3) {
        _ui2.default.showArrow();
    } else {
        _ui2.default.showButton("Go!");
    }
};

Human.prototype.rowDeselected = function () {
    if (this.row.maxShift === 3) {
        _ui2.default.hideArrow();
    } else {
        _ui2.default.hideButton();
    }
};
Human.prototype.inSethakem = function (val) {
    this.row.flipped = !val;
};

exports.default = Human;

},{"./Player":7,"./ui":31}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Row = require('./Row');

var _Row2 = _interopRequireDefault(_Row);

var _Waste = require('./Waste');

var _Waste2 = _interopRequireDefault(_Waste);

var _domBinding = require('./domBinding');

var _domBinding2 = _interopRequireDefault(_domBinding);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Player = function Player(id, name) {
    this.row = new _Row2.default(id, this);
    this.waste = new _Waste2.default(id, this);
    this.id = id;
    this._score = 0;
    this._oldScore = 0;
    this.display = _domBinding2.default.createPlayerDisplay(id, name);
    this.brain = null;
    this.selected = null;

    Object.seal(this);
};

Player.prototype.setName = function (name) {
    this.display.setName(name);
};

Player.prototype.adjustPos = function () {
    this.row.adjustPos();
    this.waste.adjustPos();
    this.display.adjustPos();
};

Player.prototype.initForNewRound = function () {
    this._score = 0;
    this.row.cards = [];
    this.waste.cards = [];
    this.display.rank = null;
    this.display.moveUp = false;
    this.display.adjustPos();
    this.display.setScoreText(this._oldScore);

    // if(this.id % 2 === 1) this.brain = new McBrain(this);
    // if(this.id === 2) this.brain = new McBrain(this);
    // else if(this.id === 1) this.brain = new PomDPBrain(this);
    // else if(this.id === 2) this.brain = new randomBrain(this);
    // else this.brain = new SimpleBrain(this);
    // this.brain = new RandomBrain();
};

Player.prototype.out = function (outCards) {
    var self = this;
    outCards.forEach(function (c) {
        self.row.out(c);
    });
};

Player.prototype.takeIn = function (inCards) {
    var self = this;
    inCards.forEach(function (c) {
        self.row.addCard(c);
    });
};

Player.prototype.clearScore = function () {
    this._score = this._oldScore = 0;
};

Player.prototype.setScore = function (val) {
    this._score = val;
    this.display.setScoreText(this._oldScore + " + " + this._score);
};
Player.prototype.setHakem = function (val) {
    this.display.setHakem(val);
};

Player.prototype.finalizeScore = function () {
    this._oldScore += this._score;
    this._score = 0;
    this.display.setFinalText(this._oldScore);
};

Player.prototype.incrementScore = function (val) {
    this.setScore(this._score + val);
    if (val > 0) this.display.highlight();
};

Player.prototype.getScore = function () {
    return this._score;
};

Player.prototype.setActive = function (yes) {
    this.display.setHighlight(yes);
};

Player.prototype.watch = function () {};

Player.prototype.transferTo = function (other) {
    var cards = this.selected;
    this.selected = null;
    this.out(cards);
    other.takeIn(cards);
};

exports.default = Player;

},{"./Row":11,"./Waste":13,"./domBinding":17}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Brain = require('./Brain');

var _Brain2 = _interopRequireDefault(_Brain);

var _prematureOptimization = require('./prematureOptimization');

var _prematureOptimization2 = _interopRequireDefault(_prematureOptimization);

var _PomDPSimulator = require('./PomDPSimulator');

var _PomDPSimulator2 = _interopRequireDefault(_PomDPSimulator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

"use strict";

var removeFromUnorderedArray = _prematureOptimization2.default.removeFromUnorderedArray;
var cardsInfo = _prematureOptimization2.default.cardsInfo;

var defaultOptions = {
    time: 1000,
    c: 10
};

var PomDPBrain = function PomDPBrain(user, options) {
    if (!options) {
        options = defaultOptions;
    }

    this.c = options.c || 10;
    this.maxTime = options.time || 1000;

    this.user = user;
    this.ind = user;
    this.simulator = new _PomDPSimulator2.default(user);
    var remainingCards = [];
    for (var i = 0; i < 52; i++) {
        remainingCards.push(i);
    }
    this.root = {
        count: 0,
        value: 0,
        observations: {},
        info: {
            playersInfo: [{
                hasCards: [],
                lackCard: {},
                numCards: 13,
                score: 0
            }, {
                hasCards: [],
                lackCard: {},
                numCards: 13,
                score: 0
            }, {
                hasCards: [],
                lackCard: {},
                numCards: 13,
                score: 0
            }, {
                hasCards: [],
                lackCard: {},
                numCards: 13,
                score: 0
            }],
            remainingCards: remainingCards,
            curBoard: [],
            heartBroken: false,
            cardLackCount: remainingCards.map(function () {
                return 0;
            })
        }
    };
    this.observationBuffer = [];
};

PomDPBrain.prototype = Object.create(_Brain2.default.prototype);

PomDPBrain.prototype.search = function (vc) {
    var endTime = Date.now() + this.maxTime;
    var times = 0;
    while (Date.now() < endTime) {
        var state = this.genSample(this.root);
        this.simulate(state, this.root, 0);
        times++;
    }
    var actions = Object.keys(this.root.actions).map(function (a) {
        return parseInt(a, 10);
    }),
        gameactions = vc.map(function (v) {
        return v.id;
    });
    actions.forEach(function (a) {
        if (gameactions.indexOf(a) === -1) {
            throw "mismatch " + a;
        }
        removeFromUnorderedArray(gameactions, a);
    });
    if (gameactions.length) throw "mismatch " + gameactions.join(" ");

    var best = -1 / 0,
        bestAction = 0;
    for (var a in this.root.actions) {
        if (this.root.actions[a].value > best) {
            best = this.root.actions[a].value;
            bestAction = a;
        }
    }
    this.root = this.root.actions[bestAction];
    return bestAction;
};

PomDPBrain.prototype.rollout = function (s, h, depth) {
    // h.count++;
    var val = this.simulator.run(s);
    // h.value = ((h.count - 1) * h.value + val) / h.count;
    return val;
};

PomDPBrain.prototype.simulate = function (s, h, depth) {
    if (h.terminate) return 0;
    if (!h.actions) {
        var as = h.actions = {};
        this.getAllActions(h).forEach(function (a) {
            if (a == "undefined" || !a && a !== 0) throw a;
            as[a] = this.initAction(h, a);
        }.bind(this));
        return this.rollout(s, h, depth);
    }
    var best,
        bestScore = -1 / 0;
    for (var a in h.actions) {
        var score = this.getScore(h.actions[a]);
        if (score > bestScore) {
            bestScore = score;
            best = a;
        }
    }
    if (!best) {
        throw "eh";
    }

    var simulateResult = this.simulator.step(s, parseInt(best, 10));

    var ha = h.actions[best],
        ohash = simulateResult.observation.join("");
    if (!(ohash in ha.observations)) {
        ha.observations[ohash] = this.initObservation(ha, simulateResult.observation);
    }

    var r = simulateResult.score + this.simulate(simulateResult.state, ha.observations[ohash], depth + 1);
    h.count++;
    ha.count++;
    ha.value = (ha.value * (ha.count - 1) + r) / ha.count;
    return r;
};

PomDPBrain.prototype.getScore = function (action) {
    if (!action.count) return 1 / 0;
    return action.value + this.c * Math.sqrt(Math.log(action.parent.count) / action.count);
};

PomDPBrain.prototype.getAllActions = function (history) {
    var info = history.info;
    if (info.curBoard.length) {
        var suit = cardsInfo[info.curBoard[0] % 100].suit;
        var r = info.playersInfo[this.ind].hasCards.filter(function (c) {
            return cardsInfo[c].suit === suit;
        });
        if (!r.length) {
            return [].concat(info.playersInfo[this.ind].hasCards);
        } else {
            return r;
        }
    } else if (info.playersInfo[this.ind].hasCards.length === 13) {
        return [26];
    } else if (info.heartBroken) {
        return [].concat(info.playersInfo[this.ind].hasCards);
    } else {
        var possible = info.playersInfo[this.ind].hasCards.filter(function (c) {
            return cardsInfo[c].suit !== 1;
        });
        if (possible.length) return possible;else return [].concat(info.playersInfo[this.ind].hasCards);
    }
};

PomDPBrain.prototype.initObservation = function (history, observation) {
    var pinfo = history.info;
    var curBoard = [].concat(pinfo.curBoard),
        heartBroken = pinfo.heartBroken,
        playersInfo = pinfo.playersInfo.map(function (info) {
        return {
            hasCards: [].concat(info.hasCards),
            lackCard: Object.create(info.lackCard),
            numCards: info.numCards,
            score: info.score
        };
    }),
        remainingCards = [].concat(pinfo.remainingCards),
        cardLackCount = [].concat(pinfo.cardLackCount);
    var info = {
        curBoard: curBoard,
        heartBroken: heartBroken,
        playersInfo: playersInfo,
        hash: observation.join(""),
        cardLackCount: cardLackCount,
        remainingCards: remainingCards
    };
    observation.forEach(function (ob) {
        var pid = (ob / 100 | 0) - 1;
        playersInfo[pid].numCards--;
        this.removeRemainingCard(ob % 100, info);
        heartBroken = heartBroken || cardsInfo[ob % 100].suit === 1;
        var curSuit;
        if (curBoard.length) {
            curSuit = cardsInfo[curBoard[0] % 100].suit;
            if (curSuit) {
                if (curSuit !== cardsInfo[ob % 100].suit) {
                    var lackCardPlayer = playersInfo[pid];
                    remainingCards.forEach(function (c) {
                        if (cardsInfo[c].suit === curSuit) {
                            lackCardPlayer.lackCard[c] = true;
                            cardLackCount[c]++;
                        }
                    });
                }
            }
        }
        curBoard.push(ob);
        if (curBoard.length === 4) {
            var maxNum = -1,
                maxPlayer = 0,
                boardScore = 0;
            for (var i = 0; i < 4; i++) {
                var bcard = cardsInfo[curBoard[i] % 100];
                if (bcard.suit === curSuit && bcard.num > maxNum) {
                    maxPlayer = (curBoard[i] / 100 | 0) - 1;
                    maxNum = bcard.num;
                }
                if (bcard.suit === 1) boardScore++;else if (bcard.suit === 0 && bcard.num === 11) boardScore += 13;
            }
            playersInfo[maxPlayer].score += boardScore;
            curBoard.length = 0;
        }
    }.bind(this));
    info.heartBroken = heartBroken;
    remainingCards.sort(function (a, b) {
        return cardLackCount[b] - cardLackCount[a];
    });

    var terminate = !playersInfo.some(function (p) {
        return p.numCards > 0;
    });

    return {
        info: info,
        count: 0,
        value: 0,
        terminate: terminate
    };
};

PomDPBrain.prototype.initAction = function (history, action) {
    var info = history.info;
    var curBoard = [].concat(info.curBoard),
        heartBroken = info.heartBroken,
        playersInfo = info.playersInfo.map(function (info) {
        return {
            hasCards: [].concat(info.hasCards),
            lackCard: Object.create(info.lackCard),
            numCards: info.numCards,
            score: info.score
        };
    }),
        remainingCards = [].concat(info.remainingCards),
        cardLackCount = [].concat(info.cardLackCount);
    return {
        value: 0,
        count: 0,
        parent: history,
        action: action,
        observations: {},
        info: {
            curBoard: curBoard,
            heartBroken: heartBroken,
            playersInfo: playersInfo,
            cardLackCount: cardLackCount,
            remainingCards: remainingCards
        }
    };
};

PomDPBrain.prototype.removeRemainingCard = function (id, info) {
    removeFromUnorderedArray(info.remainingCards, id);
    info.playersInfo.forEach(function (p, ind) {
        removeFromUnorderedArray(p.hasCards, id);
    });
};

PomDPBrain.prototype.watch = function (info) {
    if (info.type === "in") {
        info.cards.forEach(function (c) {
            this.removeRemainingCard(c, this.root.info);
        }.bind(this));
        [].push.apply(this.root.info.playersInfo[info.player].hasCards, info.cards);
    } else {
        this.observationBuffer.push(info.card + (info.player + 1) * 100);
    }
};

PomDPBrain.prototype.confirmCards = function (cards) {
    cards.forEach(function (c) {
        this.removeRemainingCard(c, this.root.info);
        this.root.info.playersInfo[this.ind].hasCards.push(c);
    }.bind(this));
};

PomDPBrain.prototype.decide = function (vc) {
    if (this.observationBuffer.join("") in this.root) {
        this.root = this.root[this.observationBuffer.join("")];
    } else {
        this.root = this.initObservation(this.root, this.observationBuffer);
    }
    this.observationBuffer = [];

    var action = parseInt(this.search(vc, this.root), 10);

    for (var i = 0; i < vc.length; i++) {
        if (vc[i].id === action) {
            return vc[i].ind;
        }
    }
    throw "failed to find card, something must be of wrongness";
};

PomDPBrain.prototype.genSample = function (node) {
    var id = this.ind,
        sample = [[], [], [], []],
        playersInfo = node.info.playersInfo,
        remainingCards = node.info.remainingCards;

    var tryT = 1000,
        ind;
    while (tryT--) {
        sample.forEach(function (p, ind) {
            p.length = 0;
            p.id = ind;
        });
        playersInfo.forEach(function (p, ind) {
            [].push.apply(sample[ind], p.hasCards);
        });
        var toAdd = sample.filter(function (s, ind) {
            return s.length < playersInfo[ind].numCards;
        });
        ind = 0;
        var sum = 0;
        var summ = 0;
        toAdd.forEach(function (to) {
            sum += to.length;
            summ += playersInfo[to.id].numCards;
        });
        while (ind < remainingCards.length) {
            var c = remainingCards[ind];
            var allPossible = toAdd.length;
            var aid = 0;
            while (aid < allPossible) {
                if (playersInfo[toAdd[aid].id].lackCard[c]) {
                    allPossible--;
                    var tmp = toAdd[allPossible];
                    toAdd[allPossible] = toAdd[aid];
                    toAdd[aid] = tmp;
                } else {
                    aid++;
                }
            }
            if (allPossible === 0) {
                break;
            }
            var pToAdd = Math.floor(Math.random() * allPossible);
            toAdd[pToAdd].push(c);
            ind++;
            if (toAdd[pToAdd].length === playersInfo[toAdd[pToAdd].id].numCards) {
                removeFromUnorderedArray(toAdd, toAdd[pToAdd]);
                if (toAdd.length === 0) {
                    break;
                }
            }
        }
        if (ind === remainingCards.length) {
            break;
        }
    }
    if (tryT === -1) {
        alert("fail to gen sample");
    }
    if (sample.some(function (s, ind) {
        return s.length !== playersInfo[ind].numCards;
    })) {
        throw "eh";
    }
    return {
        players: sample,
        scores: node.info.playersInfo.map(function (info) {
            return info.score;
        }),
        board: node.info.curBoard.concat([]),
        heartBroken: node.info.heartBroken
    };
};

exports.default = PomDPBrain;

},{"./Brain":3,"./PomDPSimulator":9,"./prematureOptimization":28}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _prematureOptimization = require('./prematureOptimization');

var _prematureOptimization2 = _interopRequireDefault(_prematureOptimization);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var removeFromUnorderedArray = _prematureOptimization2.default.removeFromUnorderedArray;
var cardsInfo = _prematureOptimization2.default.cardsInfo;

var PomDPSimulator = function PomDPSimulator(id) {
    this.observationBuffer = [];
    this.playerId = id;
    this.tmpVc = [];
};

PomDPSimulator.prototype._playCard = function (card) {
    var playerCard = (this.curPlayer + 1) * 100 + card;

    var board = this.state.board;
    this.state.board.push(playerCard);
    this.observationBuffer.push(playerCard);

    removeFromUnorderedArray(this.state.players[this.curPlayer], card);

    var boardScore = 0,
        curSuit,
        maxPlayer,
        maxNum = 0;

    if (this.state.board.length === 4) {
        curSuit = cardsInfo[board[0] % 100].suit;
        for (var i = 0; i < 4; i++) {
            var player = (board[i] / 100 | 0) - 1,
                c = cardsInfo[board[i] % 100];
            if (c.suit === 1) {
                boardScore += 1;
            } else if (c.num === 11 && c.suit === 0) {
                boardScore += 13;
            }
            if (c.suit === curSuit && c.num > maxNum) {
                maxNum = c.num;
                maxPlayer = player;
            }
        }
        this.state.scores[maxPlayer] += boardScore;
        this.curPlayer = maxPlayer;
        this.state.board.length = 0;
    } else {
        this.curPlayer = (this.curPlayer + 1) % 4;
    }
};

PomDPSimulator.prototype._getValidCards = function (cards) {
    var vc = this.tmpVc;
    this.tmpVc.length = 0;
    if (this.state.board.length === 0) {
        if (cards.length === 13) {
            this.tmpVc.push(26);
        } else if (this.state.heartBroken) {
            [].push.apply(this.tmpVc, cards);
        } else {
            cards.forEach(function (c) {
                if (cardsInfo[c].suit !== 1) {
                    vc.push(c);
                }
            });
        }
    } else {
        var suit = cardsInfo[this.state.board[0] % 100].suit;
        cards.forEach(function (c) {
            if (cardsInfo[c].suit === suit) {
                vc.push(c);
            }
        });
    }
    if (!vc.length) {
        [].push.apply(vc, cards);
    }

    return this.tmpVc;
};

PomDPSimulator.prototype._decide = function (player) {
    var cards = this.state.players[player];
    if (!cards.length) return null;
    var vc = this._getValidCards(cards),
        len = vc.length,
        suit = -1,
        maxNum = -1,
        board = this.state.board;

    if (board.length) {
        suit = cardsInfo[board[0] % 100].suit;
        maxNum = board.reduce(function (prev, curc) {
            var cur = cardsInfo[curc % 100];
            if (cur.suit === suit && cur.num > prev) {
                return cur.num;
            } else {
                return prev;
            }
        }, 0);
        return vc.reduce(function (prevc, curc) {
            var cur = cardsInfo[curc],
                prev = cardsInfo[prevc];
            if (prev.suit === cur.suit) {
                if (cur.suit === suit) {
                    if (cur.num < maxNum) {
                        if (prev.num > maxNum || prev.num < cur.num) return curc;else return prevc;
                    } else if (cur.num > maxNum && prev.num > maxNum && board.length === 3) {
                        if (cur.num > prev.num) return curc;else return prevc;
                    } else if (cur.num < prev.num) {
                        return curc;
                    } else {
                        return prevc;
                    }
                } else {
                    if (cur.num > prev.num) return curc;else return prevc;
                }
            } else {
                if (cur.suit === 0 && cur.num === 11) return curc;
                if (prev.suit === 0 && prev.num === 11) return prevc;
                if (cur.suit === 1) return curc;
                if (prev.suit === 1) return prevc;
                if (cur.num > prev.num) return curc;
                return prevc;
            }
        });
    } else {
        return vc.reduce(function (prev, cur) {
            if (cardsInfo[prev].num > cardsInfo[cur].num) return cur;else return prev;
        });
    }
};

PomDPSimulator.prototype.step = function (s, a) {
    var players = s.players,
        heartBroken = s.heartBroken,
        board = s.board,
        scores = s.scores,
        oriScore = s.scores[this.playerId];
    this.state = s;
    this.curPlayer = this.playerId;

    this._playCard(a);

    while (this.curPlayer !== this.playerId) {
        var toPlay = this._decide(this.curPlayer);
        if (toPlay === null) break;
        this._playCard(toPlay);
    }
    var moonShooter = -1,
        outputScore = oriScore - this.state.scores[this.playerId];
    this.state.scores.forEach(function (s, ind) {
        if (s === 26) {
            moonShooter = ind;
        }
    });
    if (moonShooter !== -1) {
        if (moonShooter === this.playerId) {
            outputScore = oriScore + 26;
        } else {
            outputScore = oriScore - 26;
        }
    }
    var result = {
        state: s,
        observation: this.observationBuffer.concat([]),
        score: outputScore
    };

    this.observationBuffer.length = 0;

    return result;
};

PomDPSimulator.prototype.run = function (s) {
    var players = s.players,
        heartBroken = s.heartBroken,
        board = s.board,
        oriScore = s.scores[this.playerId];
    this.state = s;
    this.curPlayer = this.playerId;

    while (1) {
        var toPlay = this._decide(this.curPlayer);
        if (toPlay === null) break;
        this._playCard(toPlay);
    }
    var moonShooter = -1,
        outputScore = oriScore - this.state.scores[this.playerId];
    this.state.scores.forEach(function (s, ind) {
        if (s === 26) moonShooter = ind;
    });
    if (moonShooter !== -1) {
        if (moonShooter === this.playerId) {
            outputScore = oriScore + 26;
        } else {
            outputScore = oriScore - 26;
        }
    }

    this.observationBuffer.length = 0;

    return outputScore;
};

exports.default = PomDPSimulator;

},{"./prematureOptimization":28}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Brain = require('./Brain');

var _Brain2 = _interopRequireDefault(_Brain);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import $ from './jquery-2.0.3.min'


var RandomBrain = function RandomBrain(user) {
    _Brain2.default.call(this, user);
};

RandomBrain.prototype = Object.create(_Brain2.default.prototype);

RandomBrain.prototype.decide = function (validCards) {
    return $.Deferred().resolve(validCards[Math.floor(Math.random() * validCards.length)].ind);
};

exports.default = RandomBrain;

},{"./Brain":3}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _layout = require('./layout');

var _layout2 = _interopRequireDefault(_layout);

var _game_sendCard = require('./game_sendCard');

var _game_sendCard2 = _interopRequireDefault(_game_sendCard);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Row = function Row(id, player) {
    this.id = id;
    this.cards = [];
    this.isVertical = id % 2;
    this.rotation = 90 * ((id + 1) % 4) - 90;
    this.curShifted = [];
    this.flipped = true;
    this.playedBy = player;
};

Row.prototype.addCard = function (card) {
    card.parent = this;
    card.ind = this.cards.length;
    this.cards.push(card);
};

Row.prototype.getSelected = function () {
    return [].concat(this.curShifted);
};

Row.prototype.setSelected = function (cards) {
    this.curShifted = [].concat(cards);
};

Row.prototype.adjustPos = function () {
    if (this.isVertical) {
        this.distance = _layout2.default.width / 2 - _layout2.default.rowMargin - _layout2.default.cardHeight / 2;
    } else {
        this.distance = _layout2.default.height / 2 - _layout2.default.rowMargin - _layout2.default.cardHeight / 1;
    }
    this.left = -((this.cards.length - 1) * _layout2.default.cardSep) / 2;
    this.cards.forEach(function (c) {
        c.adjustPos();
    });
};

Row.prototype.getPosFor = function (ind, card) {
    var pos = {};
    if (card.parent.id === 0) pos = {
        x: this.left + ind * _layout2.default.cardSep,
        y: this.distance - 30,
        rotation: this.rotation + (this.left + ind * _layout2.default.cardSep) / 24,
        ind: ind,
        rootRotation: this.rotation,
        rotateY: this.flipped ? 180 : 0,
        z: ind
    };else pos = {
        x: (this.left + ind * _layout2.default.cardSep) / 4,
        y: this.distance,
        rotation: this.rotation,
        ind: ind,
        rootRotation: this.rotation,
        rotateY: this.flipped ? 180 : 0,
        z: ind
    };

    if (this.curShifted.indexOf(this.cards[ind]) > -1) {
        pos.y -= 30;
    }
    return pos;
};

Row.prototype.sort = function () {
    this.cards.sort(function (a, b) {
        if (a.suit !== b.suit) return b.suit - a.suit;
        return a.num - b.num;
    }).forEach(function (v, ind) {
        v.ind = ind;
    });
    this.adjustPos();
};

Row.prototype.addShift = function (nc) {
    (0, _game_sendCard2.default)(this, nc, window.game);
    // if(this.curShifted.length === this.maxShift){
    //     this.curShifted.shift();
    // }
    // this.curShifted.push(nc);
    // if(this.curShifted.length === this.maxShift){
    //     this.playedBy.rowSelected(this.maxShift);
    // }
    this.adjustPos();
};

Row.prototype.out = function (card) {
    card.parent = null;
    var ind = this.cards.indexOf(card);
    this.curShifted = [];
    this.cards.splice(ind, 1);
    for (var i = ind; i < this.cards.length; i++) {
        this.cards[i].ind = i;
    }
    this.adjustPos();
};

Row.prototype.removeShift = function (nc) {
    this.curShifted = this.curShifted.filter(function (v) {
        return v !== nc;
    });
    this.playedBy.rowDeselected();
    this.adjustPos();
};

Row.prototype.hideOut = function (ind) {
    var tmp = this.cards[ind];
    var mid = Math.floor(this.cards.length / 2);
    this.cards[ind] = this.cards[mid];
    this.cards[mid] = tmp;
    this.cards[ind].ind = ind;
    this.cards[mid].ind = mid;
    if (!window.isDebug) {
        this.cards[ind].display.style[vendorPrefix + 'Transition'] = 'none';
        this.cards[mid].display.style[vendorPrefix + 'Transition'] = 'none';
    }
    this.cards[mid].adjustPos();
    this.cards[ind].adjustPos();
    if (!window.isDebug) {
        this.cards[ind].display.style[vendorPrefix + 'Transition'] = '';
        this.cards[mid].display.style[vendorPrefix + 'Transition'] = '';
    }
    var self = this;
    setTimeout(function () {
        self.out(mid, true);
    }, window.isDebug ? 0 : 100);
};

exports.default = Row;

},{"./game_sendCard":22,"./layout":24}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Brain = require('./Brain');

var _Brain2 = _interopRequireDefault(_Brain);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SimpleBrain = function SimpleBrain(user) {
    _Brain2.default.call(this, user);
};

SimpleBrain.prototype = Object.create(_Brain2.default.prototype);

SimpleBrain.prototype.decide = function (vc, board) {
    var len = vc.length,
        suit = -1,
        maxNum = -1;

    return $.Deferred().resolve(function () {
        if (board.length) {
            suit = board[0].suit;
            maxNum = board.reduce(function (prev, cur) {
                if (cur.suit === suit && cur.num > prev) {
                    return cur.num;
                } else {
                    return prev;
                }
            }, 0);
            return vc.reduce(function (prev, cur) {
                if (prev.suit === cur.suit) {
                    if (cur.suit === suit) {
                        if (cur.num < maxNum) {
                            if (prev.num > maxNum || prev.num < cur.num) return cur;else return prev;
                        } else if (cur.num > maxNum && prev.num > maxNum && board.length === 3) {
                            if (cur.num > prev.num) return cur;else return prev;
                        } else if (cur.num < prev.num) {
                            return cur;
                        } else {
                            return prev;
                        }
                    } else {
                        if (cur.num > prev.num) return cur;else return prev;
                    }
                } else {
                    if (cur.suit === 0 && cur.num === 11) return cur;
                    if (prev.suit === 0 && prev.num === 11) return prev;
                    if (cur.suit === 1) return cur;
                    if (prev.suit === 1) return prev;
                    if (cur.num > prev.num) return cur;
                    return prev;
                }
            }).ind;
        } else {
            return vc.reduce(function (prev, cur) {
                if (prev.num > cur.num) return cur;else return prev;
            }).ind;
        }
    }());
};

exports.default = SimpleBrain;

},{"./Brain":3}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _layout = require('./layout');

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Waste = function Waste(id, player) {
    this.id = id;
    this.isVertical = id % 2;
    this.rotation = 90 * ((id + 1) % 4) - 90;
    this.cards = [];
    this.playedBy = player;
};

Waste.prototype.adjustPos = function () {
    if (this.isVertical) {
        this.distance = _layout2.default.width / 2 + _layout2.default.rowMargin + _layout2.default.cardHeight / 2;
    } else {
        this.distance = _layout2.default.height / 2 + _layout2.default.rowMargin + _layout2.default.cardHeight / 2;
    }
    this.cards.forEach(function (c) {
        c.adjustPos();
    });
};

Waste.prototype.getPosFor = function (ind) {
    return {
        x: 0,
        y: this.distance,
        rotation: this.rotation,
        z: ind + 52,
        rotateY: 0
    };
};

Waste.prototype.addCards = function (cards) {
    this.playedBy.incrementScore(cards.reduce(function (p, c) {
        if (c.suit === 1) {
            return p + 1;
        } else if (c.suit === 0 && c.num === 11) {
            return p + 13;
        } else {
            return p;
        }
    }, 0));
    var finalCard = void 0;
    for (var i = 0; i < cards.length; i++) {
        if (cards[i].pos.rotation === this.rotation) {
            cards[i].pos.z = 104;
            finalCard = cards[i];
        } else {
            cards[i].pos.rotation = this.rotation;
            this.addCard(cards[i]);
        }
    }

    this.addCard(finalCard);
    var self = this;
    setTimeout(function () {
        self.adjustPos();
    }, 300);
};

Waste.prototype.addCard = function (card) {
    card.parent = this;
    card.ind = this.cards.length;
    this.cards.push(card);
};

exports.default = Waste;

},{"./layout":24}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Card = require('./Card');

var _Card2 = _interopRequireDefault(_Card);

var _layout = require('./layout');

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cards = [];
////import $ from './jquery-2.0.3.min'

for (var i = 0; i < 52; i++) {
    cards.push(new _Card2.default(i));
}

var carddeck = [];
for (i = 0; i < 52; i++) {
    carddeck.push(i);
}
exports.default = {
    cards: cards,
    init: function init() {
        this.desk.cards.length = 0;
        this.desk.players.length = 0;
        var self = this;
        this.cards.forEach(function (c) {
            c.parent = self;
            c.display.setSelectable(false);
        });
    },
    shuffleDeck: function shuffleDeck() {
        var i;

        for (i = 0; i < 52; i++) {
            var ran = Math.floor(Math.random() * (52 - i));
            var tmp = carddeck[ran];
            carddeck[ran] = carddeck[51 - i];
            carddeck[51 - i] = tmp;
        }

        for (i = 51; i >= 0; i--) {
            this.cards[carddeck[i]].ind = carddeck[i];
            this.cards[carddeck[i]].adjustPos();
        }
    },
    distribute: function distribute(players) {
        /*  alert('dis');
            var curI = 0;
          var d = $.Deferred();
          function move(){
              if(curI === cards.length){
                  setTimeout(function(){
                      d.resolve();
                  }, 200);
                  return;
              }
              players[curI % 4].row.addCard(cards[carddeck[curI]]);
              players[curI % 4].row.adjustPos();
              curI++;
              setTimeout(move, 100);
          }
          setTimeout(function(){move();}, 300);
            return d;*/
    },
    setHakem: function setHakem(players) {

        var curI = 0;
        var d = $.Deferred();

        // players[0].row.addCard(cards[1]);
        function move() {
            if (curI === cards.length) {
                setTimeout(function () {
                    d.resolve();
                }, 200);
                return;
            }
            //players[curI % 4].row.addCard(cards[carddeck[curI]]);
            //   players[curI % 4].row.addCard(cards[carddeck[curI]]);
            //   players[curI % 4].row.addCard(cards[curI]);
            // alert(cards[curI]);
            players[curI % 4].row.adjustPos();
            curI++;
            setTimeout(move, 100);
        }

        setTimeout(function () {
            move();
        }, 300);

        return d;
    },

    getPosFor: function getPosFor(ind) {
        return {
            x: (52 - ind) / 4,
            y: (52 - ind) / 4,
            z: -i,
            rotateY: 180
        };
    },
    desk: {
        cards: [],
        players: [],
        curScore: 0,
        getPosFor: function getPosFor(ind) {
            var pos = {
                x: 0,
                y: _layout2.default.cardHeight / 2 + _layout2.default.cardWidth / 2,
                z: ind + 52,
                rotateY: 0
            };
            pos.rotation = this.cards[ind].pos.rotation;
            return pos;
        },
        addCard: function addCard(card, player) {
            card.pos.rotation = card.pos.rootRotation;
            card.ind = this.cards.length;
            this.cards.push(card);
            this.players.push(player);
            card.parent = this;
        },
        adjustPos: function adjustPos() {
            this.cards.forEach(function (c) {
                c.adjustPos();
            });
        },
        score: function score() {
            var max = 0;
            for (var i = 1; i < 4; i++) {
                if (this.cards[i].suit === this.cards[max].suit && this.cards[i].num > this.cards[max].num) {
                    max = i;
                }
            }
            var p = this.players[max],
                self = this;
            var nextTime = 600,
                time = 800;
            if (window.isDebug) {
                nextTime = 0;
                time = 0;
            }
            var info = [this.players[max], [].concat(this.cards)];
            this.players.length = 0;
            this.cards.length = 0;

            return info;
        }
    },
    moveCard: {
        toPlayer: function toPlayer(id, card, players) {
            players[id].row.addCard(cards[card]);
            players[id].row.sort();
        }
    },
    newCards: function newCards() {
        var cards = [];
        for (var i = 0; i < 52; i++) {
            cards.push(new _Card2.default(i));
        }
    },
    selectibleCard: function selectibleCard(card, x) {
        cards[card].display.setSelectable(x);
    }
};

},{"./Card":4,"./layout":24}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
var names;
var myName = void 0;
var levels = [-1, 1, 2, 3];
var location;
var players;
var room_id;
var suit;
var wasteCards = [];

var STN = {
    buttom: 0,
    left: 1,
    top: 2,
    right: 3
};
var NTS = {
    0: "bottom",
    1: "left",
    2: "top",
    3: "right"
};

exports.default = {
    setMyName: function setMyName(name) {
        myName = name;
    },
    getMyName: function getMyName() {
        return myName;
    },
    getNames: function getNames() {
        return names;
    },
    levels: levels,
    sync: function sync() {
        /*  localStorage.setItem("names", JSON.stringify(names));
          localStorage.setItem("levels", JSON.stringify(levels));*/
    },
    setLocation: function setLocation(l) {
        location = l;
    },
    getLocation: function getLocation() {
        return location;
    },
    getPlayers: function getPlayers(array) {
        var me = void 0;
        var others = [];
        array.forEach(function (player) {
            if (player.location === location) me = player;else others.push(player);
        });
        return { me: me, others: others };
    },
    getLocOfPlayers: function getLocOfPlayers(player) {
        if (location === 0) {
            if (player.location === 0) return 0;
            if (player.location === 1) return 1;
            if (player.location === 3) return 3;
            if (player.location === 2) return 2;
        } else if (location === 1) {
            if (player.location === 0) return 3;
            if (player.location === 1) return 0;
            if (player.location === 3) return 2;
            if (player.location === 2) return 1;
        } else if (location === 3) {
            if (player.location === 0) return 1;
            if (player.location === 1) return 2;
            if (player.location === 3) return 0;
            if (player.location === 2) return 3;
        } else if (location === 2) {
            if (player.location === 0) return 2;
            if (player.location === 1) return 3;
            if (player.location === 3) return 1;
            if (player.location === 2) return 0;
        }
    },
    getPlayersSaved: function getPlayersSaved() {
        return players;
    },
    setNames: function setNames(namesOBJ) {
        // alert('set name');
        names = namesOBJ;
    },
    setRoom_id: function setRoom_id(x) {
        room_id = x;
    },
    setSuit: function setSuit(x) {
        suit = x;
    },
    getSuit: function getSuit() {
        return suit;
    },
    getRoom_id: function getRoom_id() {
        return room_id;
    },
    get: function get() {
        return this;
    },
    getWasteCards: function getWasteCards() {
        return wasteCards;
    },
    setWasteCards: function setWasteCards(x) {
        wasteCards = x;
    }
};

},{}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function () {
    getNameSpace();
};

var _socket_io = require('./socket_io');

var _socket_io2 = _interopRequireDefault(_socket_io);

var _loadingPage = require('./loadingPage');

var _loadingPage2 = _interopRequireDefault(_loadingPage);

var _loginPage = require('./loginPage');

var _loginPage2 = _interopRequireDefault(_loginPage);

var _ui = require('./ui');

var _ui2 = _interopRequireDefault(_ui);

var _game_core = require('./game_core');

var _game_core2 = _interopRequireDefault(_game_core);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _Debug = require('./Debug');

var _Debug2 = _interopRequireDefault(_Debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

////import $ from './jquery-2.0.3.min'
var room = void 0;
var ns = {};
ns["/hokm"] = "hokm";
ns["/IGHokm"] = "globalHokm";
var nameSpace = void 0;
var socket = null;
var socket_ID = null;
//const serverPort = 443;
var setIntervalTime = 15000;
var lastCOM = void 0;
var evenDisconnected = false;
var pingTimeStart = null;
var pinginterval = null;
var pingResp = true;
var token = void 0;

var pingTimeDom = $("#pingTime");
var globalGame = {
    id: null,
    userName: null,
    getMyData: function getMyData() {
        var pageURL = document.location.href;
        var url = new URL(pageURL);
        this.id = url.searchParams.get('id');
        this.userName = url.searchParams.get("userName") || "USER";
    }

};

var loginRoom = {
    hokm: function hokm() {
        room = document.location.search.replace('?game=', '');
        _config2.default.setRoom_id(room);
        socket.emit('loginRoom', { socket_ID: socket_ID, room: room });
    },
    globalHokm: function globalHokm() {

        socket.emit('singUpGlobalRoom', { id: globalGame.id, userName: globalGame.userName });
        loginPgae({ loginData: false });
    }
};
var connectTOS = function connectTOS(CB) {

    socket = socketConnect();

    window.socket = socket;

    socket.on("connect", onConnect);
    socket.on("disconnect", function (r) {
        pingTimeDom.html("Disconnected !");
        evenDisconnected = true;
        console.log("socket disconnect", r);
        _Debug2.default.log("disconnect");
    });
    socket.on('checkOK', function (res) {
        if (res) {
            _loadingPage2.default.load(false);
            loginPgae();
        }
    });
    socket.on('config', function (mess) {
        console.log('config', mess);
        _config2.default.setRoom_id(mess.room_id);
        _config2.default.setLocation(mess.location);
    });
    socket.on('GAME', function (mess) {
        console.log(mess);
        lastCOM = mess;
        (0, _game_core2.default)(mess);
        if (mess.mess_ID) socket.emit('_CALLBACK', mess.mess_ID);
        _Debug2.default.log("GAME", mess);
    });
    socket.on('connect_error', function (error) {
        console.log('connect_error', error);
    });
    socket.on('error', function (error) {
        console.log('error', error);
        _Debug2.default.log("socket error", error);
    });
    socket.on('connect_timeout', function (error) {
        console.log('connect_timeout', error);
    });
    socket.on('reconnect', function (x) {
        console.log('reconnect', x);
    });
    socket.on('reconnecting', function (x) {
        console.log('reconnecting', x);
    });
    socket.on('reconnect_error', function (x) {
        console.log('reconnect_error', x);
    });
    socket.on('reconnect_failed', function (x) {
        console.log('reconnect_failed', x);
    });
    socket.on('setSocketID', function (id) {
        socket_ID = id;
    });
    socket.on('room_id', function (room_id) {
        room = room_id;
    });
    socket.on('pongT', function () {
        pingResp = true;
        var newTime = new Date().getTime();
        var pingTime = newTime - pingTimeStart;
        updatePingDom(pingTime + " ms");
    });
    socket.on('errBOX', function (res) {
        _ui2.default.showMessage(res);
        _loadingPage2.default.load(false);
    });
    socket.on('debug', function (m) {
        console.log('deb', m);
        _Debug2.default.log("deb", m);
    });
    socket.on('token', function (t) {
        token = t;
    });
};

function getNameSpace() {
    nameSpace = ns[document.location.pathname];
    if (nameSpace === "hokm") {
        room = document.location.search.replace('?game=', '');
        if (!room) {
            _loadingPage2.default.load(false);
            _ui2.default.showMessage("شماره بازی وجود ندارد.");
            socket.disconnect();
            return;
        }
        connectTOS();
    } else if (nameSpace === "globalHokm") {
        globalGame.getMyData();
        _config2.default.setMyName(globalGame.userName);
        connectTOS();
    }
}

function loginPgae(data) {
    (0, _loginPage2.default)(data);
}

function onConnect() {
    _Debug2.default.log("connected");
    pingTimeDom.html("Connected");
    if (token) socket.emit('token', token);else if (!evenDisconnected) loginRoom[nameSpace]();else alert("اتصال شما با سرور ناپایدار است.");
    window.gameEmitor = function (COM, res) {
        if (!socket.connected) return alert('اتصال شما با سرور قطع شده است');
        socket.emit('GAME', {
            COM: COM,
            res: res
        });
    };
    _loadingPage2.default.errBoxRemove();
    if (pinginterval) clearInterval(pinginterval);
    pinginterval = setInterval(ping, setIntervalTime);
}

function socketConnect() {
    var pageURL = document.location;
    socket = (0, _socket_io2.default)(pageURL.host + ('/' + nameSpace), {
        reconnection: true,
        reconnectionDelay: 200,
        reconnectionDelayMax: 1000,
        transports: ['websocket']
    });
    socket.heartbeatTimeout = 20000;
    return socket;
}

function ping() {
    if (!pingResp) updatePingDom("Time Out!!");
    pingResp = false;
    pingTimeStart = new Date().getTime();
    socket.emit('pingT', true);
}

function updatePingDom(ping) {
    pingTimeDom.html(ping);
}

pingTimeDom.on('click', function () {
    window.socket.emit("debug");
    _Debug2.default.show();
});

},{"./Debug":5,"./config":15,"./game_core":21,"./loadingPage":25,"./loginPage":26,"./socket_io":30,"./ui":31}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var chats = ['سلام!', '❤️😍', 'چه دستی!', 'دمت گرم!', 'خیلی کارت درسته!', 'چرا؟', 'از من یاد بگیر', 'عالیییییی!', '👌👌', 'اینم دسته؟'];
var suits = ['spade', 'heart', 'club', 'diamond'];
var cardTrans = {
    A: 1,
    2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10,
    J: 11, Q: 12, K: 13
};

var frag;

var CardDisplay = function CardDisplay(dom) {
    this.dom = $(dom);
    this.dom.on("click", function () {
        ///click every card
        this.onClick && this.onClick();
    }.bind(this));
};
var getCardIconPos = function getCardIconPos(numtext) {
    var num = cardTrans[numtext] - 1;
    var posY = Math.floor(num / 5);
    var posX = num % 5;
    return {
        x: posX * -82,
        y: posY * -107
    };
};

CardDisplay.prototype.adjustPos = function (pos) {
    if (!pos.rotation) {
        pos.rotation = 0;
    }
    if (!pos.rotateY) {
        pos.rotateY = 0;
    }
    var zIndex = 10 + pos.z;
    this.dom.css({
        zIndex: zIndex,
        transform: 'rotate(' + pos.rotation + 'deg) translate3d(' + pos.x + 'px, ' + pos.y + 'px, ' + pos.z + 'px) rotateY(' + pos.rotateY + 'deg)'
    });
    this.zIndex = zIndex;
};

CardDisplay.prototype.setSelectable = function (yes) {
    if (yes) {
        this.dom.addClass("movable");
        this.dom.css({
            zIndex: self.zIndex + 20
        });
    } else {
        this.dom.removeClass("movable");
    }
};

CardDisplay.prototype.grayScale = function (yes) {
    var self = this;
    if (yes) {
        this.dom.addClass("grayScale");
    } else {
        this.dom.removeClass("grayScale");
    }
};

CardDisplay.prototype.isSelectable = function () {
    return this.dom.is(".movable");
};

var PlayerDisplay = function PlayerDisplay(id, name, human) {

    this.id = id;
    this.display = document.createElement('div');
    this.display.className = 'info-board board-' + id;
    if (id === 0) this.display.className = 'info-board selfBoard board-' + id;
    this.nametext = document.createElement('div');
    this.nametext.className = 'player-name';
    this.nametext.innerHTML = name;

    this.hakemTag = document.createElement('div');
    this.hakemTag.className = 'hakemTag';

    this.chatbar = document.createElement('div');
    this.chatbar.className = 'chatbar';

    this.display.appendChild(this.nametext);
    this.display.appendChild(this.hakemTag);
    this.display.appendChild(this.chatbar);

    frag.appendChild(this.display);

    this.rank = null;
};

PlayerDisplay.prototype.setName = function (name) {
    this.nametext.innerHTML = name;
};
PlayerDisplay.prototype.setHakem = function (yes) {
    if (yes) {
        this.hakemTag.className += " true";
    } else this.hakemTag.className = "hakemTag";
};
PlayerDisplay.prototype.setTurn = function (val) {
    var display = $(this.display);
    val ? display.addClass("highlight") : display.removeClass("highlight");
};
PlayerDisplay.prototype.showChat = function (mess) {
    var chatbar = $(this.chatbar);
    chatbar.removeClass('anim');
    void this.chatbar.offsetWidth;
    chatbar.html(mess).addClass('anim');
};

PlayerDisplay.prototype.offline = function (mode) {
    var display = $(this.display);
    mode ? display.addClass('offline') : display.removeClass('offline');
};

PlayerDisplay.prototype.setHuman = function (yes) {
    if (yes) {
        this.display.className += " human";
    }
};

PlayerDisplay.prototype.setHighlight = function (yes) {
    if (yes) {
        $(this.display).addClass("highlight");
    } else {
        $(this.display).removeClass("highlight");
    }
};

PlayerDisplay.prototype.adjustPos = function () {};

PlayerDisplay.prototype.setScoreText = function (text) {
    //  this.scoretext.innerHTML = text;
};

PlayerDisplay.prototype.setFinalText = function (text) {
    //  this.finaltext.innerHTML = text;
};

PlayerDisplay.prototype.highlight = function () {
    // var b = this.scoretext.classList;
    // b.add('highlight');
    // setTimeout(function(){
    //     b.remove('highlight');
    // }, 100);
};

var ChatDesk = function ChatDesk() {
    this.display = document.createElement('div');
    var chatsSider = document.createElement('div');
    chatsSider.classList = "chatsSider";
    chats.forEach(function (chatMess) {
        var chat = document.createElement('div');
        chat.innerHTML = chatMess;
        chat.className = "chatBox";
        chat.onclick = function () {
            window.gameEmitor("chat", chatMess);
        };
        chatsSider.appendChild(chat);
    });
    this.display.appendChild(chatsSider);
    this.display.className = 'chatDesk';
};

exports.default = {
    fragmentToDom: function fragmentToDom(dom) {
        if (frag) {
            dom.appendChild(frag);
            frag = null;
        }
    },
    createChatDesk: function createChatDesk() {
        var cd = new ChatDesk();
        frag.appendChild(cd.display);
    },
    createPlayerDisplay: function createPlayerDisplay(id, name) {
        return new PlayerDisplay(id, name);
    },
    createCardDisplay: function createCardDisplay(numtext, suit) {
        if (!frag) {
            frag = document.createDocumentFragment();
        }
        var display = document.createElement('div');
        display.className = 'card flipped';
        $(display).css({
            transform: 'rotateY(180deg)'
        });

        var numText = document.createElement('div');
        numText.className = 'num';
        numText.innerHTML = numtext;

        var front = document.createElement('div');
        front.className = 'front';
        //front.appendChild(numText);
        //display.classList.add(suits[suit]);
        var cardPicPos = getCardIconPos(numtext);

        var pic = document.createElement('div');
        $(pic).css({
            background: 'url(../files/img/card/' + suit + '.png) ' + cardPicPos.x + 'px ' + cardPicPos.y + 'px',
            scale: "1.2"
        });
        pic.className = 'card_pic';

        var icon = document.createElement('div');
        icon.className = 'icon';
        front.appendChild(icon);
        front.appendChild(pic);

        display.appendChild(front);

        var back = document.createElement('div');
        back.className = 'back';

        display.appendChild(back);

        frag.appendChild(display);

        return new CardDisplay(display);
    }
};

},{}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var files = ['./files/img/carp.jpg', './files/img/club.png', './files/img/crown.png', './files/img/diamond.png', './files/img/flip.png', './files/img/heart.png', './files/img/card/0.png', './files/img/card/1.png', './files/img/card/2.png', './files/img/card/3.png'];
var filesLoaded = 0;
var progressBar = $('#progress_bar');
var fileOnload = function fileOnload() {
    filesLoaded++;
    var persent = Math.floor(filesLoaded / files.length * 100);
    progressBar.css('width', persent + '%');
};

exports.default = function () {
    return Promise.all(files.map(function (f) {
        return new Promise(function (resolve) {
            var newImg = new Image();
            newImg.onload = function () {
                console.log(f + ' loaded');
                fileOnload();
                resolve();
            };
            newImg.src = f;
        });
    }));
};

},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var responsive = function responsive() {

    var basePage = {
        width: 1000,
        m_width: 600,
        height: 750,
        m_height: 450,
        scale: 1,
        scaleX: 1,
        scaleY: 1
    };

    var page = $('#game_view');
    var body = $('body');

    scalePages(page, window.innerWidth, window.innerHeight);
    $(window).resize(function () {
        return scalePages(page, window.innerWidth, window.innerHeight);
    });

    function scalePages(page, maxWidth, maxHeight) {
        var scaleX = 1,
            scaleY = 1;

        if (maxWidth > maxHeight) {
            // landscape
            scaleX = maxWidth / basePage.width;
            scaleY = maxHeight / basePage.height;
            basePage.scaleX = scaleX;
            basePage.scaleY = scaleY;

            basePage.scale = scaleX > scaleY ? scaleY : scaleX;
        } else if (maxWidth <= maxHeight) {
            // portrait
            scaleX = maxWidth / basePage.m_width;
            scaleY = maxHeight / basePage.m_height;
            basePage.scaleX = scaleX;
            basePage.scaleY = scaleY;
            basePage.scale = scaleX;
        }

        var width = Math.abs(Math.ceil(maxWidth / basePage.scale));
        var height = Math.abs(Math.ceil(maxHeight / basePage.scale));
        if (basePage.scale >= 1) {
            basePage.scale = 1;
            width = maxWidth;
            height = maxHeight;
        }
        page.attr('style', '-webkit-transform:scale(' + basePage.scale + '); width:' + width + 'px; height:' + height + 'px;');
    }
};

function toggleFullScreen() {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen();else if (document.exitFullscreen) document.exitFullscreen();
}

function preventDefault(e) {
    if (e.preventDefault) e.preventDefault();
}

function disable_scroll_mobile() {
    document.addEventListener('touchmove', preventDefault, false);
}

exports.default = function () {
    disable_scroll_mobile();
    window.scrollTo(0, 0);
    responsive();
    window.scrollTo(0, 0);
    document.ondblclick = toggleFullScreen;
};

},{}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ui = require('./ui');

var _ui2 = _interopRequireDefault(_ui);

var _Human = require('./Human');

var _Human2 = _interopRequireDefault(_Human);

var _Ai = require('./Ai');

var _Ai2 = _interopRequireDefault(_Ai);

var _board = require('./board');

var _board2 = _interopRequireDefault(_board);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _rules = require('./rules');

var _rules2 = _interopRequireDefault(_rules);

var _RandomBrain = require('./RandomBrain');

var _RandomBrain2 = _interopRequireDefault(_RandomBrain);

var _AsyncBrain = require('./AsyncBrain');

var _AsyncBrain2 = _interopRequireDefault(_AsyncBrain);

var _SimpleBrain = require('./SimpleBrain');

var _SimpleBrain2 = _interopRequireDefault(_SimpleBrain);

var _PomDPBrain = require('./PomDPBrain');

var _PomDPBrain2 = _interopRequireDefault(_PomDPBrain);

var _domBinding = require('./domBinding');

var _domBinding2 = _interopRequireDefault(_domBinding);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var players = [];
var rounds = void 0;
var status = void 0,
    currentPlay = void 0,
    played = void 0;
var heartBroken = void 0;
var nextTimer = void 0;
var waitDefer = void 0;
var initBrains = void 0;
var informCardOut = void 0;
var adds = void 0;
var getPlayerForTransfer = void 0;

var game = {};
game.load = function () {
    rounds = 0;
    players = [new _Human2.default(0, _config2.default.getNames()[0]), new _Ai2.default(1, _config2.default.getNames()[1]), new _Ai2.default(2, _config2.default.getNames()[2]), new _Ai2.default(3, _config2.default.getNames()[3])];

    status = "prepare";
    currentPlay = 0;
    played = 0;

    heartBroken = false;

    nextTimer = 0;
    _domBinding2.default.createChatDesk();

    waitDefer = function waitDefer(time) {
        var d = $.Deferred();
        setTimeout(function () {
            d.resolve();
        }, time);
        return d;
    };

    initBrains = function initBrains() {
        // players[0].brain = new AsyncBrain(players[0], "PomDPBrain");

        if (players[1].brain) {
            players[1].brain.terminate();
            players[2].brain.terminate();
            players[3].brain.terminate();
        }

        for (var i = 1; i < 4; i++) {
            if (_config2.default.levels[i] == 1) {
                players[i].brain = new _SimpleBrain2.default(players[i]);
            } else if (_config2.default.levels[i] == 2) {
                players[i].brain = new _AsyncBrain2.default(players[i], "McBrain");
            } else if (_config2.default.levels[i] == 3) {
                players[i].brain = new _AsyncBrain2.default(players[i], "PomDPBrain");
            } else if (_config2.default.levels[i] == 4) {
                players[i].brain = new _AsyncBrain2.default(players[i], "PomDPBrain", { time: 2000 });
            }
        }

        return $.when(players[1].brain.init(), players[2].brain.init(), players[3].brain.init());
    };

    informCardOut = function informCardOut(player, card) {
        if (card.suit === 1) {
            heartBroken = true;
        }
        players.forEach(function (p) {
            p.watch({
                type: "out",
                player: player,
                card: card,
                curSuit: _board2.default.desk.cards[0].suit
            });
        });
    };

    adds = [1, 3, 2];
    getPlayerForTransfer = function getPlayerForTransfer(id) {
        return (id + adds[rounds % 3]) % 4;
    };
};

game.run = {
    adjustLayout: function adjustLayout() {
        players.forEach(function (r) {
            r.adjustPos();
        });
        _board2.default.desk.adjustPos();
    },
    newGame: function newGame() {
        clearTimeout(nextTimer);
        _ui2.default.hideWin();
        players.forEach(function (p, i) {
            p.clearScore();
            p.setActive(false);
            p.setName(_config2.default.getNames()[i]);
            p.setName(_config2.default.getNames()[i]);
        });
        rounds = 0;
        _ui2.default.clearEvents();
        status = 'prepare';
        this.proceed();
    },
    next: function next() {
        console.log(status, "next");
        if (status == 'confirming') {
            currentPlay = _board2.default.cards[26].parent.playedBy.id;
            played = 0;
        } else if (status == 'playing') {
            currentPlay = (currentPlay + 1) % 4;
            played++;
        }
        if (played == 4) {
            status = 'endRound';
            played = 0;
        } else if (status == 'endRound' && players[0].row.cards.length === 0) {
            status = 'end';
        } else {
            status = {
                // 'prepare': 'setHakem', this1
                'setHakem': 'distribute',
                'distribute': 'start',
                'start': 'passing',
                'passing': 'confirming',
                'confirming': 'playing',
                'playing': 'playing',
                'endRound': 'playing',
                'end': 'prepare'
            }[status];
        }
        var waitTime = {
            'playing': 100,
            'endRound': 900,
            'distribute': 300,
            'end': 900
        };
        var wait = waitTime[status] || 0;
        nextTimer = setTimeout(this.proceed.bind(this), wait);
    },
    proceed: function proceed() {
        ({
            'prepare': function prepare() {
                _ui2.default.hideMessage();
                _ui2.default.hideButton();
                players.forEach(function (p) {
                    p.initForNewRound();
                    p.inSethakem(true);
                });
                _board2.default.init();
                heartBroken = false;
                _board2.default.shuffleDeck();
                //  initBrains().done(this.next.bind(this));

            },
            'setHakem': function setHakem() {
                var self = this;
                _board2.default.setHakem(players).done(function () {
                    players.forEach(function (p) {
                        p.row.sort();
                    });
                    //self.next();
                });
            },
            "clearTable": function clearTable() {
                //ui.hideMessage();
                _ui2.default.hideButton();
                //board.newCards();
                players.forEach(function (p) {
                    p.inSethakem(false);
                    p.initForNewRound();
                    p.clearScore();
                });
                players[0].inSethakem(true);
                _board2.default.init();
                _board2.default.shuffleDeck();
            },
            "newRound": function newRound() {
                //  var self = this;
                /* board.setHakem(players).done(function(){
                     players.forEach(function(p){
                         p.row.sort();
                     });
                     //self.next();
                   });*/
                players.forEach(function (p) {
                    p.row.sort();
                });
            },
            'distribute': function distribute() {
                var self = this;
                _board2.default.distribute(players).done(function () {
                    players.forEach(function (p) {
                        p.row.sort();
                    });
                    self.next();
                });
            },
            'start': function start() {
                rounds++;
                $.when.apply($, players.map(function (p) {
                    return p.prepareTransfer(rounds % 3);
                })).done(this.next.bind(this));
            },
            'passing': function passing() {
                for (var i = 0; i < 4; i++) {
                    players[i].transferTo(players[getPlayerForTransfer(i)]);
                }
                this.next();
            },
            'confirming': function confirming() {
                players.forEach(function (r) {
                    r.row.sort();
                });
                $.when.apply($, players.map(function (p) {
                    return p.confirmTransfer();
                })).done(this.next.bind(this));
            },
            'playing': function playing() {
                players[currentPlay].setActive(true);
                $.when(players[currentPlay].decide(_rules2.default.getValidCards(players[currentPlay].row.cards, _board2.default.desk.cards[0] ? _board2.default.desk.cards[0].suit : -1, heartBroken), _board2.default.desk.cards, _board2.default.desk.players, players.map(function (p) {
                    return p.getScore();
                })), waitDefer(200)).done(function (card) {
                    players[currentPlay].setActive(false);
                    card.parent.out(card);
                    _board2.default.desk.addCard(card, players[currentPlay]);
                    card.adjustPos();
                    informCardOut(players[currentPlay], card);
                    this.next();
                }.bind(this));
            },
            'endRound': function endRound() {
                // let info = board.desk.score();
                // currentPlay = info[0].id;
                // console.log(currentPlay);
                //   info[0].waste.addCards(info[1]);
                //this.next();
            },
            'removeRow': function removeRow() {
                // alert('deleteRow');
                players.forEach(function (p) {
                    p.row.cards.forEach(function (c) {
                        c.parent = null;
                    });
                    p.row.cards = [];
                });
            },
            'end': function end() {
                if (players.some(function (p) {
                    return p.getScore() === 26;
                })) {
                    players.forEach(function (p) {
                        if (p.getScore() !== 26) {
                            p.setScore(26);
                        } else {
                            p.setScore(0);
                        }
                    });
                }
                players.forEach(function (p) {
                    p.finalizeScore();
                });
                var rank = players.map(function (c) {
                    return c;
                });
                rank.sort(function (a, b) {
                    return a._oldScore - b._oldScore;
                });
                rank.forEach(function (r, ind) {
                    r.display.rank = ind;
                });
                players.forEach(function (p) {
                    p.adjustPos();
                });
                if (players.some(function (p) {
                    return p._oldScore >= 100;
                })) {
                    players.forEach(function (p) {
                        p.display.moveUp = true;
                        p.display.adjustPos();
                    });
                    _ui2.default.showWin(players[0] === rank[0]);
                    _ui2.default.showButton("Restart");
                    _ui2.default.buttonClickOnce(this.newGame.bind(this));
                } else {
                    _ui2.default.showButton("Continue");
                    _ui2.default.buttonClickOnce(this.next.bind(this));
                }
            }
        })[status].bind(this)();
    },
    setStatus: function setStatus(newStatus, andRun) {
        status = newStatus;
        if (andRun) this.proceed();
    },
    moveCard: {
        toPlayer: function toPlayer(id, card) {
            _board2.default.moveCard.toPlayer(id, card, players);
        },
        toTable: function toTable(player_id, card) {
            card.parent.out(card);
            _board2.default.desk.addCard(card, players[player_id]);
            card.adjustPos();
        }
    },
    setHakem: function setHakem(player_id) {
        players.forEach(function (p) {
            p.setHakem(false);
        });
        players[player_id].setHakem(true);
    },
    getPlayers: function getPlayers() {
        return players;
    },
    toWast: function toWast(winnerCard) {
        // players[0].waste.addCards(card);//////
        var info = _board2.default.desk.score();
        currentPlay = info[0].id;
        info[0].waste.addCards(info[1], winnerCard);
    },
    chatPlayer: function chatPlayer(player_id, mess) {
        players[player_id].display.showChat(mess);
    },

    returnPlayer: function returnPlayer(player_id) {
        return players[player_id];
    }
};

exports.default = game;

},{"./Ai":1,"./AsyncBrain":2,"./Human":6,"./PomDPBrain":8,"./RandomBrain":10,"./SimpleBrain":12,"./board":14,"./config":15,"./domBinding":17,"./rules":29,"./ui":31}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
//import $ from './jquery-2.0.3.min'


exports.default = function (mess) {
    room_id = _config2.default.getRoom_id();
    var COM = void 0;
    var res = void 0;
    if (mess.COM) COM = mess.COM;
    if (mess.res) res = mess.res;
    if (typeof routers[COM] === "function") routers[COM](res);
};

var _loadingPage = require('./loadingPage');

var _loadingPage2 = _interopRequireDefault(_loadingPage);

var _main = require('./main');

var _main2 = _interopRequireDefault(_main);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _ui = require('./ui');

var _ui2 = _interopRequireDefault(_ui);

var _game = require('./game');

var _game2 = _interopRequireDefault(_game);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cardDelay = 170;

var setHokmDOM = $('#setHokm');
var hokm_icon = $("#hokm_icon");
var room_id = _config2.default.getRoom_id();
var gameEnd_frame = $('#gameEnd');
var desk = $("#team-score");

$('#hokm_gish').click(function () {
    send_hokm('gish');
});
$('#hokm_del').click(function () {
    send_hokm('del');
});
$('#hokm_pik').click(function () {
    send_hokm('pik');
});
$('#hokm_khesht').click(function () {
    send_hokm('khesht');
});
var testBut = $("#testBut");
testBut.click(function () {
    window.socket.emit("getMyID", true);
});

function send_hokm(hokm) {
    if (window.socket.connected) {
        window.gameEmitor('setHokm', { hokm: hokm });
        setHokmDOM.removeClass('show').addClass('hide');
    }
}

var game_start = function game_start(mess) {
    var location = {};
    _loadingPage2.default.errBoxRemove();
    _loadingPage2.default.load(false);
    var players = _config2.default.getPlayers(mess);
    location = players.me.location;
    if (location === 0) _config2.default.setNames([players.me.name, players.others[0].name, players.others[1].name, players.others[2].name]);
    if (location === 1) _config2.default.setNames([players.me.name, players.others[1].name, players.others[2].name, players.others[0].name]);
    if (location === 3) _config2.default.setNames([players.me.name, players.others[0].name, players.others[1].name, players.others[2].name]);
    if (location === 2) _config2.default.setNames([players.me.name, players.others[2].name, players.others[0].name, players.others[1].name]);
    (0, _main2.default)();
};
var game_setHakem = function game_setHakem(mess) {
    _game2.default.run.setStatus('setHakem', true);

    var hakem = _config2.default.getLocOfPlayers(mess.hakem);
    if (mess.roundOne) {
        var start = _config2.default.getLocOfPlayers(mess.start);
        for (var i = 0; i <= mess.i; i++) {
            var player = (start + i) % 4;
            _game2.default.run.moveCard.toPlayer(player, mess.cards[i]);
        }
    }
    setTimeout(function () {
        _game2.default.run.setHakem(hakem);
        _ui2.default.showMoveMess('حاکم: ' + mess.hakem.name);
    }, 1000);
};
var game_newRound = function game_newRound(mess) {
    if (mess.mode === 'setHokm') {
        var cards = mess.hakemCards;
        var hakem = mess.hakem;
        _game2.default.run.setStatus('clearTable', true);
        var hakem_location = _config2.default.getLocOfPlayers(hakem);
        if (cards) {
            var i = 0;
            cards.forEach(function () {
                _game2.default.run.moveCard.toPlayer(hakem_location, cards[i]);
                i++;
            });
        }
    } else if (mess.mode === 'allPlayers') {
        var _cards = mess.cards;
        var _hakem = mess.hakem;
        var _hakem_location = _config2.default.getLocOfPlayers(_hakem);
        if (_cards) {

            var five = 0;
            var r = 0,
                newfive = 0;
            var _i = 0;

            var moveA = function moveA() {
                if (r === 3) newfive = 1;
                if (five === 5) {
                    five = newfive;
                    r++;
                }
                five++;
                var player = (_hakem_location + r) % 4;
                if (!(r === 0 && newfive === 0)) _game2.default.run.moveCard.toPlayer(player, mess.cards[_i]);
                _i++;
                moveB();
            };

            var moveB = function moveB() {
                setTimeout(function () {
                    if (_i < _cards.length) moveA();
                }, cardDelay);
            };

            moveA();
        }
    }
};
var game_setHokm = function game_setHokm(mess) {
    if (mess) {
        _ui2.default.hideMessage();
        var pos = _config2.default.getLocOfPlayers(mess);
        if (pos === 0) setHokmDOM.removeClass('hide').addClass('show');
    }
};
var game_hokmSeted = function game_hokmSeted(mess) {
    setHokmDOM.removeClass('show').addClass('hide');
    var x = {
        khesht: 'حکم خشت',
        pik: 'حکم پیک',
        del: 'حکم دل',
        gish: 'حکم گیشنیز'
    };
    hokm_icon.removeClass().addClass("hokm_icon").addClass(mess);
    _ui2.default.showMoveMess(x[mess]);
};
var game_setTurn = function game_setTurn(mess) {
    _ui2.default.hideMessage();
    var players = _game2.default.run.getPlayers();
    players.forEach(function (player) {
        player.display.setTurn(false);
    });
    if (mess.player) {
        var loc = _config2.default.getLocOfPlayers(mess.player);
        if (loc === 0) {
            _ui2.default.showMoveMess('نوبت شما');
            var yourCard = _game2.default.run.getPlayers()[0].row.cards;
            var suit = mess.suit;
            _config2.default.setSuit(suit);
            if (suit === 'notSet') {
                yourCard.forEach(function (card) {
                    card.display.setSelectable(true);
                });
            } else {
                var i = 0;
                yourCard.forEach(function (card) {
                    if (card.suit === suit) {
                        card.display.setSelectable(true);
                        i++;
                    } else card.display.grayScale(true);
                });
                if (i === 0) {
                    yourCard.forEach(function (card) {
                        card.display.setSelectable(true);
                        card.display.grayScale(false);
                        card.adjustPos();
                    });
                }
            }
        } else players[loc].display.setTurn(true);
    }
};
var playerPickCard = function playerPickCard(mess) {
    var playerLoc = _config2.default.getLocOfPlayers({ location: mess.location });

    var player = _game2.default.run.getPlayers()[playerLoc];
    var cards = player.row.cards;

    var _cards$filter = cards.filter(function (c) {
        return c.id === mess.card.id;
    }),
        _cards$filter2 = _slicedToArray(_cards$filter, 1),
        card = _cards$filter2[0];

    if (card) {
        var x = _config2.default.getWasteCards();
        x.push(cards);
        _config2.default.setWasteCards(x);
        _game2.default.run.moveCard.toTable(playerLoc, card);
    }
};
var toWaste = function toWaste(mess) {
    _game2.default.run.toWast();
    _game2.default.run.setStatus("endRound", true);
    _game2.default.run.setStatus("newRound", true);
};
var game_alert = function game_alert(mess) {
    _loadingPage2.default.load(false);
    _ui2.default.showMessage(mess);
};

function deskMove(x) {
    x ? desk.removeClass("hide").addClass("show") : desk.removeClass("show").addClass("hide");
}

var teamScore = function teamScore(mess) {
    function getOurTeam(loc) {
        if (loc === 2 || loc === 0) return { our: "topB", their: "rightL" };else if (loc === 3 || loc === 1) return { our: "rightL", their: "topB" };
    }

    function roundPrint(our, their) {
        $("#score-rounds").html("حریف " + their + " | " + our + "ما ");
    }

    function gamePrint(our, their) {
        $("#score-games").html("حریف " + their + " | " + our + "ما ");
    }

    var location = _config2.default.getLocation();
    var teamLoc = getOurTeam(location);
    var round = mess.round;
    var game = mess.game;
    roundPrint(round[teamLoc.our], round[teamLoc.their]);
    gamePrint(game[teamLoc.our], game[teamLoc.their]);
    deskMove(true);
    setTimeout(function () {
        deskMove(false);
    }, 3000);
};
var gameEnd = function gameEnd(mess) {
    gameEnd_frame.removeClass("hide").addClass("show");
    deskMove(true);
    setTimeout(function () {
        _ui2.default.hideMessage();
    }, 2000);
    window.socket.disconnect();
};
var game_newPlayer = function game_newPlayer(mess) {
    _ui2.default.showMoveMess(mess.name + ' \u0648\u0627\u0631\u062F \u0628\u0627\u0632\u06CC \u0634\u062F ');
    setTimeout(function () {
        _ui2.default.showMessage('\u0622\u0646\u0644\u0627\u06CC\u0646 \u0647\u0627: ' + mess.length);
    }, 2000);
};
var game_leftPlayer = function game_leftPlayer(mess) {
    _ui2.default.showMoveMess(mess.name + ' \u0627\u0632 \u0628\u0627\u0632\u06CC \u062E\u0627\u0631\u062C \u0634\u062F ');
    setTimeout(function () {
        _ui2.default.showMessage('\u0622\u0646\u0644\u0627\u06CC\u0646 \u0647\u0627: ' + mess.length);
    }, 2000);
};
var chat = function chat(mess) {
    var playerLoc = _config2.default.getLocOfPlayers({ location: mess.location });
    _game2.default.run.chatPlayer(playerLoc, mess.message);
};
var player_disconnect = function player_disconnect(mess) {
    var playerLoc = _config2.default.getLocOfPlayers({ location: mess.location });
    _game2.default.run.chatPlayer(playerLoc, "آفلاین شد");
    var player = _game2.default.run.returnPlayer(playerLoc);
    player.display.offline(true);
};
var player_connect = function player_connect(mess) {
    var playerLoc = _config2.default.getLocOfPlayers({ location: mess.location });
    _game2.default.run.chatPlayer(playerLoc, "آنلاین شد");
    var player = _game2.default.run.returnPlayer(playerLoc);
    player.display.offline(false);
};

var routers = {
    'game_start': game_start,
    'setHakem': game_setHakem,
    'newRound': game_newRound,
    'setHokm': game_setHokm,
    'hokmSeted': game_hokmSeted,
    'setTurn': game_setTurn,
    'playerPickCard': playerPickCard,
    'toWaste': toWaste,
    'alert': game_alert,
    'teamScore': teamScore,
    'gameEnd': gameEnd,
    'newPlayer': game_newPlayer,
    'leftPlayer': game_leftPlayer,
    'chat': chat,
    'player_disconnect': player_disconnect,
    'player_connect': player_connect

};
;

},{"./config":15,"./game":20,"./loadingPage":25,"./main":27,"./ui":31}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
   value: true
});

exports.default = function (cards, nc, game) {
   if (window.socket.connected) {
      var yourCard = game.run.getPlayers()[0].row.cards;
      var hasSuit = false;
      var currnetSuit = _config2.default.getSuit() * 1;
      if (currnetSuit === 0 || currnetSuit === 1 || currnetSuit === 2 || currnetSuit === 3) {
         var plyaer_i = game.run.getPlayers()[0];
         var myCards = plyaer_i.row.cards;
         myCards.forEach(function (e) {
            if (e.suit === currnetSuit) hasSuit = true;
         });
      }

      window.gameEmitor('pickCard', {
         card: {
            id: nc.id,
            num: nc.num,
            suit: nc.suit,
            hasSuit: hasSuit
         }
      });

      yourCard.forEach(function (card) {
         card.display.setSelectable(false);
         card.display.grayScale(false);
      });
      return true;
   } else {
      alert("disconnected from server");
      return false;
   }
};

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;

},{"./config":15}],23:[function(require,module,exports){
'use strict';

var _fixPageResponsive = require('./fixPageResponsive');

var _fixPageResponsive2 = _interopRequireDefault(_fixPageResponsive);

var _connectToServer = require('./connectToServer');

var _connectToServer2 = _interopRequireDefault(_connectToServer);

var _filesLoader = require('./filesLoader');

var _filesLoader2 = _interopRequireDefault(_filesLoader);

var _ui = require('./ui');

var _ui2 = _interopRequireDefault(_ui);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_ui2.default.fragmentToDom($('#game-region')[0]);
(0, _fixPageResponsive2.default)();
(0, _filesLoader2.default)().then(function () {
   console.log('load complete');
   (0, _connectToServer2.default)();
});

},{"./connectToServer":16,"./filesLoader":18,"./fixPageResponsive":19,"./ui":31}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    width: 500,
    height: 500,
    cardSep: 42,
    cardHeight: 100,
    cardWidth: 65,
    rowMargin: 10,
    boardHeight: 55,
    boardWidth: 250,
    region: null,
    adjust: function adjust() {
        if (!this.region) return;
        this.width = this.region.offsetWidth;
        this.height = this.region.offsetHeight;
    }
};

},{}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
//import $ from './jquery-2.0.3.min'

var errBox = void 0;
var methods = {};
methods.load = function (mode) {
    if (mode) {
        $('#loading_page').removeClass('hide').addClass('show');
    } else {
        $('#loading_page').removeClass('show').addClass('hide');
    }
};
methods.errBox = function (mess) {
    errBox = $('#alert_msgbox');
    var errBox_close_btn = $('#err_msg_close');
    var errBox_text = $('#err_msg_text');
    errBox_close_btn.click(function () {
        methods.errBoxRemove();
    });
    errBox.removeClass('hide').addClass('show');
    errBox_text.html(mess);
};
methods.errBoxRemove = function () {
    //  alert('close');
    errBox = $('#alert_msgbox');
    errBox.removeClass('show').addClass('hide');
};

exports.default = methods;

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (data) {
    room = _config2.default.getRoom_id();
    if (data) {
        if (data.loginData === false) {
            userName = _config2.default.getMyName();
            loadingPageX();
        }
    } else {
        $("#login_page").removeClass("hide").addClass("show");
        location = "auto";
        userName = null;
        $('#loginButton').click(function () {
            userName = $('#userName').val();
            send();
        });
    }
};

var _loadingPage = require('./loadingPage');

var _loadingPage2 = _interopRequireDefault(_loadingPage);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _ui = require('./ui');

var _ui2 = _interopRequireDefault(_ui);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var userName = void 0; ////import $ from './jquery-2.0.3.min'

var location = void 0;
var room = _config2.default.getRoom_id();
var forceStopDom = $("#forceStop");

function loadingPageX() {
    $('#login_page').removeClass('show').addClass('hide');
    _ui2.default.showMessage("تا رسیدن بقیه بازیکن ها صبر کنید.");
    _loadingPage2.default.load(true);
    gameForceStop();
}

function send() {
    if (userName) {
        var socket = window.socket;
        socket.emit('loginRoomStart', { room_id: room, userName: userName, location: location });
        socket.on('LoginOk', function (location) {
            _config2.default.setLocation(location);
            loadingPageX();
        });
    }
}

function gameForceStop() {
    forceStopDom.click(forceStop);
    $(".forceStopIcon").removeClass('hide').addClass('show').click(function () {
        $(".stopFrame").removeClass('hide').addClass('show');
        $("#game-region").addClass('blur');
    });

    $("#forceStopCancel").click(function () {
        $(".stopFrame").removeClass('show').addClass('hide');
        $("#game-region").removeClass('blur');
    });
}

function forceStop() {
    var room_id = _config2.default.getRoom_id();
    window.socket.emit('GAME', {
        room_id: room_id,
        COM: "forceStop",
        res: {
            name: userName,
            location: location
        }
    });
    $(".stopFrame").removeClass('show').addClass('hide');
}

;

},{"./config":15,"./loadingPage":25,"./ui":31}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function () {
    //config.setNames(['a','b','c','d']);
    _game2.default.load();
    $(".cornerButton").removeClass("hide").addClass("show");

    _layout2.default.region = $('#game-region')[0];
    _layout2.default.adjust();

    _domBinding2.default.fragmentToDom($('#game-region')[0]);
    _game2.default.run.adjustLayout();

    $(window).resize(function () {
        _layout2.default.adjust();
        _game2.default.run.adjustLayout();
    });

    // var nums = ['one', 'two', 'three', 'four'];
    $('#control-region>button').on("click", function () {
        $('#control-region')[0].hidden = true;
    });
    $('#control-region>.newgame-but').on("click", function () {
        _config2.default.names.forEach(function (n, ind) {
            _config2.default.levels[ind] = $('.player-diff.' + nums[ind] + ' input').val();
            _config2.default.names[ind] = $('.player-set-name.' + nums[ind]).text();
        });
        _config2.default.sync();
    });

    $('#settings-but').on("click", function () {
        $('#settings-dialog')[0].hidden = false;
        _config2.default.names.forEach(function (n, ind) {
            $('.player-set-name.' + nums[ind])[0].innerHTML = n;
            $('.player-diff.' + nums[ind] + ' input').val(parseInt(_config2.default.levels[ind]));
            console.log(parseInt(_config2.default.levels[ind]));
        });
        $('#control-region')[0].hidden = false;
    });

    $(window).on('wheel', function (event) {
        if (event.originalEvent.deltaY < 0) $("#team-score").removeClass("show").addClass("hide");else $("#team-score").removeClass("hide").addClass("show");
    });
    _game2.default.run.newGame(); //
};

var _game = require('./game');

var _game2 = _interopRequireDefault(_game);

var _domBinding = require('./domBinding');

var _domBinding2 = _interopRequireDefault(_domBinding);

var _layout = require('./layout');

var _layout2 = _interopRequireDefault(_layout);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.game = _game2.default;
//import $ from './jquery-2.0.3.min'

},{"./config":15,"./domBinding":17,"./game":20,"./layout":24}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
var cardsInfo = [];

for (var i = 0; i < 52; i++) {
    cardsInfo.push({
        num: i % 13 + 1,
        suit: i % 4
    });
}

function infoToCardId(num, suit) {
    var r = num - 1;
    while (r % 4 !== suit) {
        r += 13;
    }
    return r;
}

function removeFromUnorderedArray(arr, item) {
    // console.trace();
    if (!arr.length) return;
    var ind = arr.indexOf(item);
    if (ind === -1) return;
    arr[ind] = arr[arr.length - 1];
    arr.pop();
}

exports.default = {
    cardsInfo: cardsInfo,
    infoToCardId: infoToCardId,
    removeFromUnorderedArray: removeFromUnorderedArray
};

},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    getValidCards: function getValidCards(cards, firstSuit, isHeartBroken) {
        if (firstSuit == -1) {
            if (isHeartBroken) {
                return cards;
            } else if (cards.length === 13) {
                for (var i = 0; i < cards.length; i++) {
                    if (cards[i].suit == 2 && cards[i].num == 1) {
                        return [cards[i]];
                    }
                }
                return null;
            } else {
                var vcards = cards.filter(function (c) {
                    return c.suit !== 1;
                });
                if (vcards.length === 0) {
                    return vcards.concat(cards);
                } else {
                    return vcards;
                }
            }
        } else {
            var vcards = cards.filter(function (c) {
                return c.suit === firstSuit;
            });
            if (vcards.length === 0) {
                return vcards.concat(cards);
            } else {
                return vcards;
            }
        }
    }
};

},{}],30:[function(require,module,exports){
(function (Buffer){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (t, e) {
    "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.io = e() : t.io = e();
}(undefined, function () {
    return function (t) {
        function e(r) {
            if (n[r]) return n[r].exports;
            var o = n[r] = { exports: {}, id: r, loaded: !1 };
            return t[r].call(o.exports, o, o.exports, e), o.loaded = !0, o.exports;
        }

        var n = {};
        return e.m = t, e.c = n, e.p = "", e(0);
    }([function (t, e, n) {
        "use strict";

        function r(t, e) {
            "object" === ("undefined" == typeof t ? "undefined" : o(t)) && (e = t, t = void 0), e = e || {};
            var n,
                r = i(t),
                s = r.source,
                u = r.id,
                h = r.path,
                f = p[u] && h in p[u].nsps,
                l = e.forceNew || e["force new connection"] || !1 === e.multiplex || f;
            return l ? (c("ignoring socket cache for %s", s), n = a(s, e)) : (p[u] || (c("new io instance for %s", s), p[u] = a(s, e)), n = p[u]), r.query && !e.query && (e.query = r.query), n.socket(r.path, e);
        }

        var o = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
            return typeof t === "undefined" ? "undefined" : _typeof(t);
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t === "undefined" ? "undefined" : _typeof(t);
        },
            i = n(1),
            s = n(7),
            a = n(12),
            c = n(3)("socket.io-client");
        t.exports = e = r;
        var p = e.managers = {};
        e.protocol = s.protocol, e.connect = r, e.Manager = n(12), e.Socket = n(36);
    }, function (t, e, n) {
        "use strict";

        function r(t, e) {
            var n = t;
            e = e || "undefined" != typeof location && location, null == t && (t = e.protocol + "//" + e.host), "string" == typeof t && ("/" === t.charAt(0) && (t = "/" === t.charAt(1) ? e.protocol + t : e.host + t), /^(https?|wss?):\/\//.test(t) || (i("protocol-less url %s", t), t = "undefined" != typeof e ? e.protocol + "//" + t : "https://" + t), i("parse %s", t), n = o(t)), n.port || (/^(http|ws)$/.test(n.protocol) ? n.port = "80" : /^(http|ws)s$/.test(n.protocol) && (n.port = "443")), n.path = n.path || "/";
            var r = n.host.indexOf(":") !== -1,
                s = r ? "[" + n.host + "]" : n.host;
            return n.id = n.protocol + "://" + s + ":" + n.port, n.href = n.protocol + "://" + s + (e && e.port === n.port ? "" : ":" + n.port), n;
        }

        var o = n(2),
            i = n(3)("socket.io-client:url");
        t.exports = r;
    }, function (t, e) {
        var n = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
            r = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
        t.exports = function (t) {
            var e = t,
                o = t.indexOf("["),
                i = t.indexOf("]");
            o != -1 && i != -1 && (t = t.substring(0, o) + t.substring(o, i).replace(/:/g, ";") + t.substring(i, t.length));
            for (var s = n.exec(t || ""), a = {}, c = 14; c--;) {
                a[r[c]] = s[c] || "";
            }return o != -1 && i != -1 && (a.source = e, a.host = a.host.substring(1, a.host.length - 1).replace(/;/g, ":"), a.authority = a.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), a.ipv6uri = !0), a;
        };
    }, function (t, e, n) {
        (function (r) {
            function o() {
                return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
            }

            function i(t) {
                var n = this.useColors;
                if (t[0] = (n ? "%c" : "") + this.namespace + (n ? " %c" : " ") + t[0] + (n ? "%c " : " ") + "+" + e.humanize(this.diff), n) {
                    var r = "color: " + this.color;
                    t.splice(1, 0, r, "color: inherit");
                    var o = 0,
                        i = 0;
                    t[0].replace(/%[a-zA-Z%]/g, function (t) {
                        "%%" !== t && (o++, "%c" === t && (i = o));
                    }), t.splice(i, 0, r);
                }
            }

            function s() {
                return "object" == (typeof console === "undefined" ? "undefined" : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
            }

            function a(t) {
                try {
                    null == t ? e.storage.removeItem("debug") : e.storage.debug = t;
                } catch (n) {}
            }

            function c() {
                var t;
                try {
                    t = e.storage.debug;
                } catch (n) {}
                return !t && "undefined" != typeof r && "env" in r && (t = r.env.DEBUG), t;
            }

            function p() {
                try {
                    return window.localStorage;
                } catch (t) {}
            }

            e = t.exports = n(5), e.log = s, e.formatArgs = i, e.save = a, e.load = c, e.useColors = o, e.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : p(), e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], e.formatters.j = function (t) {
                try {
                    return JSON.stringify(t);
                } catch (e) {
                    return "[UnexpectedJSONParseError]: " + e.message;
                }
            }, e.enable(c());
        }).call(e, n(4));
    }, function (t, e) {
        function n() {
            throw new Error("setTimeout has not been defined");
        }

        function r() {
            throw new Error("clearTimeout has not been defined");
        }

        function o(t) {
            if (u === setTimeout) return setTimeout(t, 0);
            if ((u === n || !u) && setTimeout) return u = setTimeout, setTimeout(t, 0);
            try {
                return u(t, 0);
            } catch (e) {
                try {
                    return u.call(null, t, 0);
                } catch (e) {
                    return u.call(this, t, 0);
                }
            }
        }

        function i(t) {
            if (h === clearTimeout) return clearTimeout(t);
            if ((h === r || !h) && clearTimeout) return h = clearTimeout, clearTimeout(t);
            try {
                return h(t);
            } catch (e) {
                try {
                    return h.call(null, t);
                } catch (e) {
                    return h.call(this, t);
                }
            }
        }

        function s() {
            y && l && (y = !1, l.length ? d = l.concat(d) : m = -1, d.length && a());
        }

        function a() {
            if (!y) {
                var t = o(s);
                y = !0;
                for (var e = d.length; e;) {
                    for (l = d, d = []; ++m < e;) {
                        l && l[m].run();
                    }m = -1, e = d.length;
                }
                l = null, y = !1, i(t);
            }
        }

        function c(t, e) {
            this.fun = t, this.array = e;
        }

        function p() {}

        var u,
            h,
            f = t.exports = {};
        !function () {
            try {
                u = "function" == typeof setTimeout ? setTimeout : n;
            } catch (t) {
                u = n;
            }
            try {
                h = "function" == typeof clearTimeout ? clearTimeout : r;
            } catch (t) {
                h = r;
            }
        }();
        var l,
            d = [],
            y = !1,
            m = -1;
        f.nextTick = function (t) {
            var e = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) {
                e[n - 1] = arguments[n];
            }d.push(new c(t, e)), 1 !== d.length || y || o(a);
        }, c.prototype.run = function () {
            this.fun.apply(null, this.array);
        }, f.title = "browser", f.browser = !0, f.env = {}, f.argv = [], f.version = "", f.versions = {}, f.on = p, f.addListener = p, f.once = p, f.off = p, f.removeListener = p, f.removeAllListeners = p, f.emit = p, f.prependListener = p, f.prependOnceListener = p, f.listeners = function (t) {
            return [];
        }, f.binding = function (t) {
            throw new Error("process.binding is not supported");
        }, f.cwd = function () {
            return "/";
        }, f.chdir = function (t) {
            throw new Error("process.chdir is not supported");
        }, f.umask = function () {
            return 0;
        };
    }, function (t, e, n) {
        function r(t) {
            var n,
                r = 0;
            for (n in t) {
                r = (r << 5) - r + t.charCodeAt(n), r |= 0;
            }return e.colors[Math.abs(r) % e.colors.length];
        }

        function o(t) {
            function n() {
                if (n.enabled) {
                    var t = n,
                        r = +new Date(),
                        i = r - (o || r);
                    t.diff = i, t.prev = o, t.curr = r, o = r;
                    for (var s = new Array(arguments.length), a = 0; a < s.length; a++) {
                        s[a] = arguments[a];
                    }s[0] = e.coerce(s[0]), "string" != typeof s[0] && s.unshift("%O");
                    var c = 0;
                    s[0] = s[0].replace(/%([a-zA-Z%])/g, function (n, r) {
                        if ("%%" === n) return n;
                        c++;
                        var o = e.formatters[r];
                        if ("function" == typeof o) {
                            var i = s[c];
                            n = o.call(t, i), s.splice(c, 1), c--;
                        }
                        return n;
                    }), e.formatArgs.call(t, s);
                    var p = n.log || e.log || console.log.bind(console);
                    p.apply(t, s);
                }
            }

            var o;
            return n.namespace = t, n.enabled = e.enabled(t), n.useColors = e.useColors(), n.color = r(t), n.destroy = i, "function" == typeof e.init && e.init(n), e.instances.push(n), n;
        }

        function i() {
            var t = e.instances.indexOf(this);
            return t !== -1 && (e.instances.splice(t, 1), !0);
        }

        function s(t) {
            e.save(t), e.names = [], e.skips = [];
            var n,
                r = ("string" == typeof t ? t : "").split(/[\s,]+/),
                o = r.length;
            for (n = 0; n < o; n++) {
                r[n] && (t = r[n].replace(/\*/g, ".*?"), "-" === t[0] ? e.skips.push(new RegExp("^" + t.substr(1) + "$")) : e.names.push(new RegExp("^" + t + "$")));
            }for (n = 0; n < e.instances.length; n++) {
                var i = e.instances[n];
                i.enabled = e.enabled(i.namespace);
            }
        }

        function a() {
            e.enable("");
        }

        function c(t) {
            if ("*" === t[t.length - 1]) return !0;
            var n, r;
            for (n = 0, r = e.skips.length; n < r; n++) {
                if (e.skips[n].test(t)) return !1;
            }for (n = 0, r = e.names.length; n < r; n++) {
                if (e.names[n].test(t)) return !0;
            }return !1;
        }

        function p(t) {
            return t instanceof Error ? t.stack || t.message : t;
        }

        e = t.exports = o.debug = o["default"] = o, e.coerce = p, e.disable = a, e.enable = s, e.enabled = c, e.humanize = n(6), e.instances = [], e.names = [], e.skips = [], e.formatters = {};
    }, function (t, e) {
        function n(t) {
            if (t = String(t), !(t.length > 100)) {
                var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);
                if (e) {
                    var n = parseFloat(e[1]),
                        r = (e[2] || "ms").toLowerCase();
                    switch (r) {
                        case "years":
                        case "year":
                        case "yrs":
                        case "yr":
                        case "y":
                            return n * u;
                        case "days":
                        case "day":
                        case "d":
                            return n * p;
                        case "hours":
                        case "hour":
                        case "hrs":
                        case "hr":
                        case "h":
                            return n * c;
                        case "minutes":
                        case "minute":
                        case "mins":
                        case "min":
                        case "m":
                            return n * a;
                        case "seconds":
                        case "second":
                        case "secs":
                        case "sec":
                        case "s":
                            return n * s;
                        case "milliseconds":
                        case "millisecond":
                        case "msecs":
                        case "msec":
                        case "ms":
                            return n;
                        default:
                            return;
                    }
                }
            }
        }

        function r(t) {
            return t >= p ? Math.round(t / p) + "d" : t >= c ? Math.round(t / c) + "h" : t >= a ? Math.round(t / a) + "m" : t >= s ? Math.round(t / s) + "s" : t + "ms";
        }

        function o(t) {
            return i(t, p, "day") || i(t, c, "hour") || i(t, a, "minute") || i(t, s, "second") || t + " ms";
        }

        function i(t, e, n) {
            if (!(t < e)) return t < 1.5 * e ? Math.floor(t / e) + " " + n : Math.ceil(t / e) + " " + n + "s";
        }

        var s = 1e3,
            a = 60 * s,
            c = 60 * a,
            p = 24 * c,
            u = 365.25 * p;
        t.exports = function (t, e) {
            e = e || {};
            var i = typeof t === "undefined" ? "undefined" : _typeof(t);
            if ("string" === i && t.length > 0) return n(t);
            if ("number" === i && isNaN(t) === !1) return e["long"] ? o(t) : r(t);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t));
        };
    }, function (t, e, n) {
        function r() {}

        function o(t) {
            var n = "" + t.type;
            if (e.BINARY_EVENT !== t.type && e.BINARY_ACK !== t.type || (n += t.attachments + "-"), t.nsp && "/" !== t.nsp && (n += t.nsp + ","), null != t.id && (n += t.id), null != t.data) {
                var r = i(t.data);
                if (r === !1) return g;
                n += r;
            }
            return f("encoded %j as %s", t, n), n;
        }

        function i(t) {
            try {
                return JSON.stringify(t);
            } catch (e) {
                return !1;
            }
        }

        function s(t, e) {
            function n(t) {
                var n = d.deconstructPacket(t),
                    r = o(n.packet),
                    i = n.buffers;
                i.unshift(r), e(i);
            }

            d.removeBlobs(t, n);
        }

        function a() {
            this.reconstructor = null;
        }

        function c(t) {
            var n = 0,
                r = { type: Number(t.charAt(0)) };
            if (null == e.types[r.type]) return h("unknown packet type " + r.type);
            if (e.BINARY_EVENT === r.type || e.BINARY_ACK === r.type) {
                for (var o = ""; "-" !== t.charAt(++n) && (o += t.charAt(n), n != t.length);) {}
                if (o != Number(o) || "-" !== t.charAt(n)) throw new Error("Illegal attachments");
                r.attachments = Number(o);
            }
            if ("/" === t.charAt(n + 1)) for (r.nsp = ""; ++n;) {
                var i = t.charAt(n);
                if ("," === i) break;
                if (r.nsp += i, n === t.length) break;
            } else r.nsp = "/";
            var s = t.charAt(n + 1);
            if ("" !== s && Number(s) == s) {
                for (r.id = ""; ++n;) {
                    var i = t.charAt(n);
                    if (null == i || Number(i) != i) {
                        --n;
                        break;
                    }
                    if (r.id += t.charAt(n), n === t.length) break;
                }
                r.id = Number(r.id);
            }
            if (t.charAt(++n)) {
                var a = p(t.substr(n)),
                    c = a !== !1 && (r.type === e.ERROR || y(a));
                if (!c) return h("invalid payload");
                r.data = a;
            }
            return f("decoded %s as %j", t, r), r;
        }

        function p(t) {
            try {
                return JSON.parse(t);
            } catch (e) {
                return !1;
            }
        }

        function u(t) {
            this.reconPack = t, this.buffers = [];
        }

        function h(t) {
            return { type: e.ERROR, data: "parser error: " + t };
        }

        var f = n(3)("socket.io-parser"),
            l = n(8),
            d = n(9),
            y = n(10),
            m = n(11);
        e.protocol = 4, e.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], e.CONNECT = 0, e.DISCONNECT = 1, e.EVENT = 2, e.ACK = 3, e.ERROR = 4, e.BINARY_EVENT = 5, e.BINARY_ACK = 6, e.Encoder = r, e.Decoder = a;
        var g = e.ERROR + '"encode error"';
        r.prototype.encode = function (t, n) {
            if (f("encoding packet %j", t), e.BINARY_EVENT === t.type || e.BINARY_ACK === t.type) s(t, n);else {
                var r = o(t);
                n([r]);
            }
        }, l(a.prototype), a.prototype.add = function (t) {
            var n;
            if ("string" == typeof t) n = c(t), e.BINARY_EVENT === n.type || e.BINARY_ACK === n.type ? (this.reconstructor = new u(n), 0 === this.reconstructor.reconPack.attachments && this.emit("decoded", n)) : this.emit("decoded", n);else {
                if (!m(t) && !t.base64) throw new Error("Unknown type: " + t);
                if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
                n = this.reconstructor.takeBinaryData(t), n && (this.reconstructor = null, this.emit("decoded", n));
            }
        }, a.prototype.destroy = function () {
            this.reconstructor && this.reconstructor.finishedReconstruction();
        }, u.prototype.takeBinaryData = function (t) {
            if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
                var e = d.reconstructPacket(this.reconPack, this.buffers);
                return this.finishedReconstruction(), e;
            }
            return null;
        }, u.prototype.finishedReconstruction = function () {
            this.reconPack = null, this.buffers = [];
        };
    }, function (t, e, n) {
        function r(t) {
            if (t) return o(t);
        }

        function o(t) {
            for (var e in r.prototype) {
                t[e] = r.prototype[e];
            }return t;
        }

        t.exports = r, r.prototype.on = r.prototype.addEventListener = function (t, e) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this;
        }, r.prototype.once = function (t, e) {
            function n() {
                this.off(t, n), e.apply(this, arguments);
            }

            return n.fn = e, this.on(t, n), this;
        }, r.prototype.off = r.prototype.removeListener = r.prototype.removeAllListeners = r.prototype.removeEventListener = function (t, e) {
            if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
            var n = this._callbacks["$" + t];
            if (!n) return this;
            if (1 == arguments.length) return delete this._callbacks["$" + t], this;
            for (var r, o = 0; o < n.length; o++) {
                if (r = n[o], r === e || r.fn === e) {
                    n.splice(o, 1);
                    break;
                }
            }return this;
        }, r.prototype.emit = function (t) {
            this._callbacks = this._callbacks || {};
            var e = [].slice.call(arguments, 1),
                n = this._callbacks["$" + t];
            if (n) {
                n = n.slice(0);
                for (var r = 0, o = n.length; r < o; ++r) {
                    n[r].apply(this, e);
                }
            }
            return this;
        }, r.prototype.listeners = function (t) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [];
        }, r.prototype.hasListeners = function (t) {
            return !!this.listeners(t).length;
        };
    }, function (t, e, n) {
        function r(t, e) {
            if (!t) return t;
            if (s(t)) {
                var n = { _placeholder: !0, num: e.length };
                return e.push(t), n;
            }
            if (i(t)) {
                for (var o = new Array(t.length), a = 0; a < t.length; a++) {
                    o[a] = r(t[a], e);
                }return o;
            }
            if ("object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && !(t instanceof Date)) {
                var o = {};
                for (var c in t) {
                    o[c] = r(t[c], e);
                }return o;
            }
            return t;
        }

        function o(t, e) {
            if (!t) return t;
            if (t && t._placeholder) return e[t.num];
            if (i(t)) for (var n = 0; n < t.length; n++) {
                t[n] = o(t[n], e);
            } else if ("object" == (typeof t === "undefined" ? "undefined" : _typeof(t))) for (var r in t) {
                t[r] = o(t[r], e);
            }return t;
        }

        var i = n(10),
            s = n(11),
            a = Object.prototype.toString,
            c = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === a.call(Blob),
            p = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === a.call(File);
        e.deconstructPacket = function (t) {
            var e = [],
                n = t.data,
                o = t;
            return o.data = r(n, e), o.attachments = e.length, { packet: o, buffers: e };
        }, e.reconstructPacket = function (t, e) {
            return t.data = o(t.data, e), t.attachments = void 0, t;
        }, e.removeBlobs = function (t, e) {
            function n(t, a, u) {
                if (!t) return t;
                if (c && t instanceof Blob || p && t instanceof File) {
                    r++;
                    var h = new FileReader();
                    h.onload = function () {
                        u ? u[a] = this.result : o = this.result, --r || e(o);
                    }, h.readAsArrayBuffer(t);
                } else if (i(t)) for (var f = 0; f < t.length; f++) {
                    n(t[f], f, t);
                } else if ("object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && !s(t)) for (var l in t) {
                    n(t[l], l, t);
                }
            }

            var r = 0,
                o = t;
            n(o), r || e(o);
        };
    }, function (t, e) {
        var n = {}.toString;
        t.exports = Array.isArray || function (t) {
            return "[object Array]" == n.call(t);
        };
    }, function (t, e) {
        function n(t) {
            return r && Buffer.isBuffer(t) || o && (t instanceof ArrayBuffer || i(t));
        }

        t.exports = n;
        var r = "function" == typeof Buffer && "function" == typeof Buffer.isBuffer,
            o = "function" == typeof ArrayBuffer,
            i = function i(t) {
            return "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer;
        };
    }, function (t, e, n) {
        "use strict";

        function r(t, e) {
            if (!(this instanceof r)) return new r(t, e);
            t && "object" === ("undefined" == typeof t ? "undefined" : o(t)) && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = e, this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor(e.randomizationFactor || .5), this.backoff = new l({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor()
            }), this.timeout(null == e.timeout ? 2e4 : e.timeout), this.readyState = "closed", this.uri = t, this.connecting = [], this.lastPing = null, this.encoding = !1, this.packetBuffer = [];
            var n = e.parser || c;
            this.encoder = new n.Encoder(), this.decoder = new n.Decoder(), this.autoConnect = e.autoConnect !== !1, this.autoConnect && this.open();
        }

        var o = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
            return typeof t === "undefined" ? "undefined" : _typeof(t);
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t === "undefined" ? "undefined" : _typeof(t);
        },
            i = n(13),
            s = n(36),
            a = n(8),
            c = n(7),
            p = n(38),
            u = n(39),
            h = n(3)("socket.io-client:manager"),
            f = n(35),
            l = n(40),
            d = Object.prototype.hasOwnProperty;
        t.exports = r, r.prototype.emitAll = function () {
            this.emit.apply(this, arguments);
            for (var t in this.nsps) {
                d.call(this.nsps, t) && this.nsps[t].emit.apply(this.nsps[t], arguments);
            }
        }, r.prototype.updateSocketIds = function () {
            for (var t in this.nsps) {
                d.call(this.nsps, t) && (this.nsps[t].id = this.generateId(t));
            }
        }, r.prototype.generateId = function (t) {
            return ("/" === t ? "" : t + "#") + this.engine.id;
        }, a(r.prototype), r.prototype.reconnection = function (t) {
            return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
        }, r.prototype.reconnectionAttempts = function (t) {
            return arguments.length ? (this._reconnectionAttempts = t, this) : this._reconnectionAttempts;
        }, r.prototype.reconnectionDelay = function (t) {
            return arguments.length ? (this._reconnectionDelay = t, this.backoff && this.backoff.setMin(t), this) : this._reconnectionDelay;
        }, r.prototype.randomizationFactor = function (t) {
            return arguments.length ? (this._randomizationFactor = t, this.backoff && this.backoff.setJitter(t), this) : this._randomizationFactor;
        }, r.prototype.reconnectionDelayMax = function (t) {
            return arguments.length ? (this._reconnectionDelayMax = t, this.backoff && this.backoff.setMax(t), this) : this._reconnectionDelayMax;
        }, r.prototype.timeout = function (t) {
            return arguments.length ? (this._timeout = t, this) : this._timeout;
        }, r.prototype.maybeReconnectOnOpen = function () {
            !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();
        }, r.prototype.open = r.prototype.connect = function (t, e) {
            if (h("readyState %s", this.readyState), ~this.readyState.indexOf("open")) return this;
            h("opening %s", this.uri), this.engine = i(this.uri, this.opts);
            var n = this.engine,
                r = this;
            this.readyState = "opening", this.skipReconnect = !1;
            var o = p(n, "open", function () {
                r.onopen(), t && t();
            }),
                s = p(n, "error", function (e) {
                if (h("connect_error"), r.cleanup(), r.readyState = "closed", r.emitAll("connect_error", e), t) {
                    var n = new Error("Connection error");
                    n.data = e, t(n);
                } else r.maybeReconnectOnOpen();
            });
            if (!1 !== this._timeout) {
                var a = this._timeout;
                h("connect attempt will timeout after %d", a);
                var c = setTimeout(function () {
                    h("connect attempt timed out after %d", a), o.destroy(), n.close(), n.emit("error", "timeout"), r.emitAll("connect_timeout", a);
                }, a);
                this.subs.push({
                    destroy: function destroy() {
                        clearTimeout(c);
                    }
                });
            }
            return this.subs.push(o), this.subs.push(s), this;
        }, r.prototype.onopen = function () {
            h("open"), this.cleanup(), this.readyState = "open", this.emit("open");
            var t = this.engine;
            this.subs.push(p(t, "data", u(this, "ondata"))), this.subs.push(p(t, "ping", u(this, "onping"))), this.subs.push(p(t, "pong", u(this, "onpong"))), this.subs.push(p(t, "error", u(this, "onerror"))), this.subs.push(p(t, "close", u(this, "onclose"))), this.subs.push(p(this.decoder, "decoded", u(this, "ondecoded")));
        }, r.prototype.onping = function () {
            this.lastPing = new Date(), this.emitAll("ping");
        }, r.prototype.onpong = function () {
            this.emitAll("pong", new Date() - this.lastPing);
        }, r.prototype.ondata = function (t) {
            this.decoder.add(t);
        }, r.prototype.ondecoded = function (t) {
            this.emit("packet", t);
        }, r.prototype.onerror = function (t) {
            h("error", t), this.emitAll("error", t);
        }, r.prototype.socket = function (t, e) {
            function n() {
                ~f(o.connecting, r) || o.connecting.push(r);
            }

            var r = this.nsps[t];
            if (!r) {
                r = new s(this, t, e), this.nsps[t] = r;
                var o = this;
                r.on("connecting", n), r.on("connect", function () {
                    r.id = o.generateId(t);
                }), this.autoConnect && n();
            }
            return r;
        }, r.prototype.destroy = function (t) {
            var e = f(this.connecting, t);
            ~e && this.connecting.splice(e, 1), this.connecting.length || this.close();
        }, r.prototype.packet = function (t) {
            h("writing packet %j", t);
            var e = this;
            t.query && 0 === t.type && (t.nsp += "?" + t.query), e.encoding ? e.packetBuffer.push(t) : (e.encoding = !0, this.encoder.encode(t, function (n) {
                for (var r = 0; r < n.length; r++) {
                    e.engine.write(n[r], t.options);
                }e.encoding = !1, e.processPacketQueue();
            }));
        }, r.prototype.processPacketQueue = function () {
            if (this.packetBuffer.length > 0 && !this.encoding) {
                var t = this.packetBuffer.shift();
                this.packet(t);
            }
        }, r.prototype.cleanup = function () {
            h("cleanup");
            for (var t = this.subs.length, e = 0; e < t; e++) {
                var n = this.subs.shift();
                n.destroy();
            }
            this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy();
        }, r.prototype.close = r.prototype.disconnect = function () {
            h("disconnect"), this.skipReconnect = !0, this.reconnecting = !1, "opening" === this.readyState && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close();
        }, r.prototype.onclose = function (t) {
            h("onclose"), this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", t), this._reconnection && !this.skipReconnect && this.reconnect();
        }, r.prototype.reconnect = function () {
            if (this.reconnecting || this.skipReconnect) return this;
            var t = this;
            if (this.backoff.attempts >= this._reconnectionAttempts) h("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1;else {
                var e = this.backoff.duration();
                h("will wait %dms before reconnect attempt", e), this.reconnecting = !0;
                var n = setTimeout(function () {
                    t.skipReconnect || (h("attempting reconnect"), t.emitAll("reconnect_attempt", t.backoff.attempts), t.emitAll("reconnecting", t.backoff.attempts), t.skipReconnect || t.open(function (e) {
                        e ? (h("reconnect attempt error"), t.reconnecting = !1, t.reconnect(), t.emitAll("reconnect_error", e.data)) : (h("reconnect success"), t.onreconnect());
                    }));
                }, e);
                this.subs.push({
                    destroy: function destroy() {
                        clearTimeout(n);
                    }
                });
            }
        }, r.prototype.onreconnect = function () {
            var t = this.backoff.attempts;
            this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", t);
        };
    }, function (t, e, n) {
        t.exports = n(14), t.exports.parser = n(21);
    }, function (t, e, n) {
        function r(t, e) {
            return this instanceof r ? (e = e || {}, t && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && (e = t, t = null), t ? (t = u(t), e.hostname = t.host, e.secure = "https" === t.protocol || "wss" === t.protocol, e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = u(e.host).host), this.secure = null != e.secure ? e.secure : "undefined" != typeof location && "https:" === location.protocol, e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.agent = e.agent || !1, this.hostname = e.hostname || ("undefined" != typeof location ? location.hostname : "localhost"), this.port = e.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? 443 : 80), this.query = e.query || {}, "string" == typeof this.query && (this.query = h.decode(this.query)), this.upgrade = !1 !== e.upgrade, this.path = (e.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!e.forceJSONP, this.jsonp = !1 !== e.jsonp, this.forceBase64 = !!e.forceBase64, this.enablesXDR = !!e.enablesXDR, this.timestampParam = e.timestampParam || "t", this.timestampRequests = e.timestampRequests, this.transports = e.transports || ["polling", "websocket"], this.transportOptions = e.transportOptions || {}, this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = e.policyPort || 843, this.rememberUpgrade = e.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = e.onlyBinaryUpgrades, this.perMessageDeflate = !1 !== e.perMessageDeflate && (e.perMessageDeflate || {}), !0 === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), this.pfx = e.pfx || null, this.key = e.key || null, this.passphrase = e.passphrase || null, this.cert = e.cert || null, this.ca = e.ca || null, this.ciphers = e.ciphers || null, this.rejectUnauthorized = void 0 === e.rejectUnauthorized || e.rejectUnauthorized, this.forceNode = !!e.forceNode, this.isReactNative = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(), ("undefined" == typeof self || this.isReactNative) && (e.extraHeaders && Object.keys(e.extraHeaders).length > 0 && (this.extraHeaders = e.extraHeaders), e.localAddress && (this.localAddress = e.localAddress)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, void this.open()) : new r(t, e);
        }

        function o(t) {
            var e = {};
            for (var n in t) {
                t.hasOwnProperty(n) && (e[n] = t[n]);
            }return e;
        }

        var i = n(15),
            s = n(8),
            a = n(3)("engine.io-client:socket"),
            c = n(35),
            p = n(21),
            u = n(2),
            h = n(29);
        t.exports = r, r.priorWebsocketSuccess = !1, s(r.prototype), r.protocol = p.protocol, r.Socket = r, r.Transport = n(20), r.transports = n(15), r.parser = n(21), r.prototype.createTransport = function (t) {
            a('creating transport "%s"', t);
            var e = o(this.query);
            e.EIO = p.protocol, e.transport = t;
            var n = this.transportOptions[t] || {};
            this.id && (e.sid = this.id);
            var r = new i[t]({
                query: e,
                socket: this,
                agent: n.agent || this.agent,
                hostname: n.hostname || this.hostname,
                port: n.port || this.port,
                secure: n.secure || this.secure,
                path: n.path || this.path,
                forceJSONP: n.forceJSONP || this.forceJSONP,
                jsonp: n.jsonp || this.jsonp,
                forceBase64: n.forceBase64 || this.forceBase64,
                enablesXDR: n.enablesXDR || this.enablesXDR,
                timestampRequests: n.timestampRequests || this.timestampRequests,
                timestampParam: n.timestampParam || this.timestampParam,
                policyPort: n.policyPort || this.policyPort,
                pfx: n.pfx || this.pfx,
                key: n.key || this.key,
                passphrase: n.passphrase || this.passphrase,
                cert: n.cert || this.cert,
                ca: n.ca || this.ca,
                ciphers: n.ciphers || this.ciphers,
                rejectUnauthorized: n.rejectUnauthorized || this.rejectUnauthorized,
                perMessageDeflate: n.perMessageDeflate || this.perMessageDeflate,
                extraHeaders: n.extraHeaders || this.extraHeaders,
                forceNode: n.forceNode || this.forceNode,
                localAddress: n.localAddress || this.localAddress,
                requestTimeout: n.requestTimeout || this.requestTimeout,
                protocols: n.protocols || void 0,
                isReactNative: this.isReactNative
            });
            return r;
        }, r.prototype.open = function () {
            var t;
            if (this.rememberUpgrade && r.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) t = "websocket";else {
                if (0 === this.transports.length) {
                    var e = this;
                    return void setTimeout(function () {
                        e.emit("error", "No transports available");
                    }, 0);
                }
                t = this.transports[0];
            }
            this.readyState = "opening";
            try {
                t = this.createTransport(t);
            } catch (n) {
                return this.transports.shift(), void this.open();
            }
            t.open(), this.setTransport(t);
        }, r.prototype.setTransport = function (t) {
            a("setting transport %s", t.name);
            var e = this;
            this.transport && (a("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = t, t.on("drain", function () {
                e.onDrain();
            }).on("packet", function (t) {
                e.onPacket(t);
            }).on("error", function (t) {
                e.onError(t);
            }).on("close", function () {
                e.onClose("transport close");
            });
        }, r.prototype.probe = function (t) {
            function e() {
                if (f.onlyBinaryUpgrades) {
                    var e = !this.supportsBinary && f.transport.supportsBinary;
                    h = h || e;
                }
                h || (a('probe transport "%s" opened', t), u.send([{
                    type: "ping",
                    data: "probe"
                }]), u.once("packet", function (e) {
                    if (!h) if ("pong" === e.type && "probe" === e.data) {
                        if (a('probe transport "%s" pong', t), f.upgrading = !0, f.emit("upgrading", u), !u) return;
                        r.priorWebsocketSuccess = "websocket" === u.name, a('pausing current transport "%s"', f.transport.name), f.transport.pause(function () {
                            h || "closed" !== f.readyState && (a("changing transport and sending upgrade packet"), p(), f.setTransport(u), u.send([{ type: "upgrade" }]), f.emit("upgrade", u), u = null, f.upgrading = !1, f.flush());
                        });
                    } else {
                        a('probe transport "%s" failed', t);
                        var n = new Error("probe error");
                        n.transport = u.name, f.emit("upgradeError", n);
                    }
                }));
            }

            function n() {
                h || (h = !0, p(), u.close(), u = null);
            }

            function o(e) {
                var r = new Error("probe error: " + e);
                r.transport = u.name, n(), a('probe transport "%s" failed because of error: %s', t, e), f.emit("upgradeError", r);
            }

            function i() {
                o("transport closed");
            }

            function s() {
                o("socket closed");
            }

            function c(t) {
                u && t.name !== u.name && (a('"%s" works - aborting "%s"', t.name, u.name), n());
            }

            function p() {
                u.removeListener("open", e), u.removeListener("error", o), u.removeListener("close", i), f.removeListener("close", s), f.removeListener("upgrading", c);
            }

            a('probing transport "%s"', t);
            var u = this.createTransport(t, { probe: 1 }),
                h = !1,
                f = this;
            r.priorWebsocketSuccess = !1, u.once("open", e), u.once("error", o), u.once("close", i), this.once("close", s), this.once("upgrading", c), u.open();
        }, r.prototype.onOpen = function () {
            if (a("socket open"), this.readyState = "open", r.priorWebsocketSuccess = "websocket" === this.transport.name, this.emit("open"), this.flush(), "open" === this.readyState && this.upgrade && this.transport.pause) {
                a("starting upgrade probes");
                for (var t = 0, e = this.upgrades.length; t < e; t++) {
                    this.probe(this.upgrades[t]);
                }
            }
        }, r.prototype.onPacket = function (t) {
            if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (a('socket receive: type "%s", data "%s"', t.type, t.data), this.emit("packet", t), this.emit("heartbeat"), t.type) {
                case "open":
                    this.onHandshake(JSON.parse(t.data));
                    break;
                case "pong":
                    this.setPing(), this.emit("pong");
                    break;
                case "error":
                    var e = new Error("server error");
                    e.code = t.data, this.onError(e);
                    break;
                case "message":
                    this.emit("data", t.data), this.emit("message", t.data);
            } else a('packet received with socket readyState "%s"', this.readyState);
        }, r.prototype.onHandshake = function (t) {
            this.emit("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.onOpen(), "closed" !== this.readyState && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat));
        }, r.prototype.onHeartbeat = function (t) {
            clearTimeout(this.pingTimeoutTimer);
            var e = this;
            e.pingTimeoutTimer = setTimeout(function () {
                "closed" !== e.readyState && e.onClose("ping timeout");
            }, t || e.pingInterval + e.pingTimeout);
        }, r.prototype.setPing = function () {
            var t = this;
            clearTimeout(t.pingIntervalTimer), t.pingIntervalTimer = setTimeout(function () {
                a("writing ping packet - expecting pong within %sms", t.pingTimeout), t.ping(), t.onHeartbeat(t.pingTimeout);
            }, t.pingInterval);
        }, r.prototype.ping = function () {
            var t = this;
            this.sendPacket("ping", function () {
                t.emit("ping");
            });
        }, r.prototype.onDrain = function () {
            this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush();
        }, r.prototype.flush = function () {
            "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (a("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"));
        }, r.prototype.write = r.prototype.send = function (t, e, n) {
            return this.sendPacket("message", t, e, n), this;
        }, r.prototype.sendPacket = function (t, e, n, r) {
            if ("function" == typeof e && (r = e, e = void 0), "function" == typeof n && (r = n, n = null), "closing" !== this.readyState && "closed" !== this.readyState) {
                n = n || {}, n.compress = !1 !== n.compress;
                var o = { type: t, data: e, options: n };
                this.emit("packetCreate", o), this.writeBuffer.push(o), r && this.once("flush", r), this.flush();
            }
        }, r.prototype.close = function () {
            function t() {
                r.onClose("forced close"), a("socket closing - telling transport to close"), r.transport.close();
            }

            function e() {
                r.removeListener("upgrade", e), r.removeListener("upgradeError", e), t();
            }

            function n() {
                r.once("upgrade", e), r.once("upgradeError", e);
            }

            if ("opening" === this.readyState || "open" === this.readyState) {
                this.readyState = "closing";
                var r = this;
                this.writeBuffer.length ? this.once("drain", function () {
                    this.upgrading ? n() : t();
                }) : this.upgrading ? n() : t();
            }
            return this;
        }, r.prototype.onError = function (t) {
            a("socket error %j", t), r.priorWebsocketSuccess = !1, this.emit("error", t), this.onClose("transport error", t);
        }, r.prototype.onClose = function (t, e) {
            if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
                a('socket close with reason: "%s"', t);
                var n = this;
                clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", t, e), n.writeBuffer = [], n.prevBufferLen = 0;
            }
        }, r.prototype.filterUpgrades = function (t) {
            for (var e = [], n = 0, r = t.length; n < r; n++) {
                ~c(this.transports, t[n]) && e.push(t[n]);
            }return e;
        };
    }, function (t, e, n) {
        function r(t) {
            var e,
                n = !1,
                r = !1,
                a = !1 !== t.jsonp;
            if ("undefined" != typeof location) {
                var c = "https:" === location.protocol,
                    p = location.port;
                p || (p = c ? 443 : 80), n = t.hostname !== location.hostname || p !== t.port, r = t.secure !== c;
            }
            if (t.xdomain = n, t.xscheme = r, e = new o(t), "open" in e && !t.forceJSONP) return new i(t);
            if (!a) throw new Error("JSONP disabled");
            return new s(t);
        }

        var o = n(16),
            i = n(18),
            s = n(32),
            a = n(33);
        e.polling = r, e.websocket = a;
    }, function (t, e, n) {
        var r = n(17);
        t.exports = function (t) {
            var e = t.xdomain,
                n = t.xscheme,
                o = t.enablesXDR;
            try {
                if ("undefined" != typeof XMLHttpRequest && (!e || r)) return new XMLHttpRequest();
            } catch (i) {}
            try {
                if ("undefined" != typeof XDomainRequest && !n && o) return new XDomainRequest();
            } catch (i) {}
            if (!e) try {
                return new self[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
            } catch (i) {}
        };
    }, function (t, e) {
        try {
            t.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
        } catch (n) {
            t.exports = !1;
        }
    }, function (t, e, n) {
        function r() {}

        function o(t) {
            if (c.call(this, t), this.requestTimeout = t.requestTimeout, this.extraHeaders = t.extraHeaders, "undefined" != typeof location) {
                var e = "https:" === location.protocol,
                    n = location.port;
                n || (n = e ? 443 : 80), this.xd = "undefined" != typeof location && t.hostname !== location.hostname || n !== t.port, this.xs = t.secure !== e;
            }
        }

        function i(t) {
            this.method = t.method || "GET", this.uri = t.uri, this.xd = !!t.xd, this.xs = !!t.xs, this.async = !1 !== t.async, this.data = void 0 !== t.data ? t.data : null, this.agent = t.agent, this.isBinary = t.isBinary, this.supportsBinary = t.supportsBinary, this.enablesXDR = t.enablesXDR, this.requestTimeout = t.requestTimeout, this.pfx = t.pfx, this.key = t.key, this.passphrase = t.passphrase, this.cert = t.cert, this.ca = t.ca, this.ciphers = t.ciphers, this.rejectUnauthorized = t.rejectUnauthorized, this.extraHeaders = t.extraHeaders, this.create();
        }

        function s() {
            for (var t in i.requests) {
                i.requests.hasOwnProperty(t) && i.requests[t].abort();
            }
        }

        var a = n(16),
            c = n(19),
            p = n(8),
            u = n(30),
            h = n(3)("engine.io-client:polling-xhr");
        if (t.exports = o, t.exports.Request = i, u(o, c), o.prototype.supportsBinary = !0, o.prototype.request = function (t) {
            return t = t || {}, t.uri = this.uri(), t.xd = this.xd, t.xs = this.xs, t.agent = this.agent || !1, t.supportsBinary = this.supportsBinary, t.enablesXDR = this.enablesXDR, t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized, t.requestTimeout = this.requestTimeout, t.extraHeaders = this.extraHeaders, new i(t);
        }, o.prototype.doWrite = function (t, e) {
            var n = "string" != typeof t && void 0 !== t,
                r = this.request({ method: "POST", data: t, isBinary: n }),
                o = this;
            r.on("success", e), r.on("error", function (t) {
                o.onError("xhr post error", t);
            }), this.sendXhr = r;
        }, o.prototype.doPoll = function () {
            h("xhr poll");
            var t = this.request(),
                e = this;
            t.on("data", function (t) {
                e.onData(t);
            }), t.on("error", function (t) {
                e.onError("xhr poll error", t);
            }), this.pollXhr = t;
        }, p(i.prototype), i.prototype.create = function () {
            var t = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
            t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized;
            var e = this.xhr = new a(t),
                n = this;
            try {
                h("xhr open %s: %s", this.method, this.uri), e.open(this.method, this.uri, this.async);
                try {
                    if (this.extraHeaders) {
                        e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);
                        for (var r in this.extraHeaders) {
                            this.extraHeaders.hasOwnProperty(r) && e.setRequestHeader(r, this.extraHeaders[r]);
                        }
                    }
                } catch (o) {}
                if ("POST" === this.method) try {
                    this.isBinary ? e.setRequestHeader("Content-type", "application/octet-stream") : e.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                } catch (o) {}
                try {
                    e.setRequestHeader("Accept", "*/*");
                } catch (o) {}
                "withCredentials" in e && (e.withCredentials = !0), this.requestTimeout && (e.timeout = this.requestTimeout), this.hasXDR() ? (e.onload = function () {
                    n.onLoad();
                }, e.onerror = function () {
                    n.onError(e.responseText);
                }) : e.onreadystatechange = function () {
                    if (2 === e.readyState) try {
                        var t = e.getResponseHeader("Content-Type");
                        n.supportsBinary && "application/octet-stream" === t && (e.responseType = "arraybuffer");
                    } catch (r) {}
                    4 === e.readyState && (200 === e.status || 1223 === e.status ? n.onLoad() : setTimeout(function () {
                        n.onError(e.status);
                    }, 0));
                }, h("xhr data %s", this.data), e.send(this.data);
            } catch (o) {
                return void setTimeout(function () {
                    n.onError(o);
                }, 0);
            }
            "undefined" != typeof document && (this.index = i.requestsCount++, i.requests[this.index] = this);
        }, i.prototype.onSuccess = function () {
            this.emit("success"), this.cleanup();
        }, i.prototype.onData = function (t) {
            this.emit("data", t), this.onSuccess();
        }, i.prototype.onError = function (t) {
            this.emit("error", t), this.cleanup(!0);
        }, i.prototype.cleanup = function (t) {
            if ("undefined" != typeof this.xhr && null !== this.xhr) {
                if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = r : this.xhr.onreadystatechange = r, t) try {
                    this.xhr.abort();
                } catch (e) {}
                "undefined" != typeof document && delete i.requests[this.index], this.xhr = null;
            }
        }, i.prototype.onLoad = function () {
            var t;
            try {
                var e;
                try {
                    e = this.xhr.getResponseHeader("Content-Type");
                } catch (n) {}
                t = "application/octet-stream" === e ? this.xhr.response || this.xhr.responseText : this.xhr.responseText;
            } catch (n) {
                this.onError(n);
            }
            null != t && this.onData(t);
        }, i.prototype.hasXDR = function () {
            return "undefined" != typeof XDomainRequest && !this.xs && this.enablesXDR;
        }, i.prototype.abort = function () {
            this.cleanup();
        }, i.requestsCount = 0, i.requests = {}, "undefined" != typeof document) if ("function" == typeof attachEvent) attachEvent("onunload", s);else if ("function" == typeof addEventListener) {
            var f = "onpagehide" in self ? "pagehide" : "unload";
            addEventListener(f, s, !1);
        }
    }, function (t, e, n) {
        function r(t) {
            var e = t && t.forceBase64;
            u && !e || (this.supportsBinary = !1), o.call(this, t);
        }

        var o = n(20),
            i = n(29),
            s = n(21),
            a = n(30),
            c = n(31),
            p = n(3)("engine.io-client:polling");
        t.exports = r;
        var u = function () {
            var t = n(16),
                e = new t({ xdomain: !1 });
            return null != e.responseType;
        }();
        a(r, o), r.prototype.name = "polling", r.prototype.doOpen = function () {
            this.poll();
        }, r.prototype.pause = function (t) {
            function e() {
                p("paused"), n.readyState = "paused", t();
            }

            var n = this;
            if (this.readyState = "pausing", this.polling || !this.writable) {
                var r = 0;
                this.polling && (p("we are currently polling - waiting to pause"), r++, this.once("pollComplete", function () {
                    p("pre-pause polling complete"), --r || e();
                })), this.writable || (p("we are currently writing - waiting to pause"), r++, this.once("drain", function () {
                    p("pre-pause writing complete"), --r || e();
                }));
            } else e();
        }, r.prototype.poll = function () {
            p("polling"), this.polling = !0, this.doPoll(), this.emit("poll");
        }, r.prototype.onData = function (t) {
            var e = this;
            p("polling got data %s", t);
            var n = function n(t, _n, r) {
                return "opening" === e.readyState && e.onOpen(), "close" === t.type ? (e.onClose(), !1) : void e.onPacket(t);
            };
            s.decodePayload(t, this.socket.binaryType, n), "closed" !== this.readyState && (this.polling = !1, this.emit("pollComplete"), "open" === this.readyState ? this.poll() : p('ignoring poll - transport state "%s"', this.readyState));
        }, r.prototype.doClose = function () {
            function t() {
                p("writing close packet"), e.write([{ type: "close" }]);
            }

            var e = this;
            "open" === this.readyState ? (p("transport open - closing"), t()) : (p("transport not open - deferring close"), this.once("open", t));
        }, r.prototype.write = function (t) {
            var e = this;
            this.writable = !1;
            var n = function n() {
                e.writable = !0, e.emit("drain");
            };
            s.encodePayload(t, this.supportsBinary, function (t) {
                e.doWrite(t, n);
            });
        }, r.prototype.uri = function () {
            var t = this.query || {},
                e = this.secure ? "https" : "http",
                n = "";
            !1 !== this.timestampRequests && (t[this.timestampParam] = c()), this.supportsBinary || t.sid || (t.b64 = 1), t = i.encode(t), this.port && ("https" === e && 443 !== Number(this.port) || "http" === e && 80 !== Number(this.port)) && (n = ":" + this.port), t.length && (t = "?" + t);
            var r = this.hostname.indexOf(":") !== -1;
            return e + "://" + (r ? "[" + this.hostname + "]" : this.hostname) + n + this.path + t;
        };
    }, function (t, e, n) {
        function r(t) {
            this.path = t.path, this.hostname = t.hostname, this.port = t.port, this.secure = t.secure, this.query = t.query, this.timestampParam = t.timestampParam, this.timestampRequests = t.timestampRequests, this.readyState = "", this.agent = t.agent || !1, this.socket = t.socket, this.enablesXDR = t.enablesXDR, this.pfx = t.pfx, this.key = t.key, this.passphrase = t.passphrase, this.cert = t.cert, this.ca = t.ca, this.ciphers = t.ciphers, this.rejectUnauthorized = t.rejectUnauthorized, this.forceNode = t.forceNode, this.isReactNative = t.isReactNative, this.extraHeaders = t.extraHeaders, this.localAddress = t.localAddress;
        }

        var o = n(21),
            i = n(8);
        t.exports = r, i(r.prototype), r.prototype.onError = function (t, e) {
            var n = new Error(t);
            return n.type = "TransportError", n.description = e, this.emit("error", n), this;
        }, r.prototype.open = function () {
            return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this;
        }, r.prototype.close = function () {
            return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this;
        }, r.prototype.send = function (t) {
            if ("open" !== this.readyState) throw new Error("Transport not open");
            this.write(t);
        }, r.prototype.onOpen = function () {
            this.readyState = "open", this.writable = !0, this.emit("open");
        }, r.prototype.onData = function (t) {
            var e = o.decodePacket(t, this.socket.binaryType);
            this.onPacket(e);
        }, r.prototype.onPacket = function (t) {
            this.emit("packet", t);
        }, r.prototype.onClose = function () {
            this.readyState = "closed", this.emit("close");
        };
    }, function (t, e, n) {
        function r(t, n) {
            var r = "b" + e.packets[t.type] + t.data.data;
            return n(r);
        }

        function o(t, n, r) {
            if (!n) return e.encodeBase64Packet(t, r);
            var o = t.data,
                i = new Uint8Array(o),
                s = new Uint8Array(1 + o.byteLength);
            s[0] = v[t.type];
            for (var a = 0; a < i.length; a++) {
                s[a + 1] = i[a];
            }return r(s.buffer);
        }

        function i(t, n, r) {
            if (!n) return e.encodeBase64Packet(t, r);
            var o = new FileReader();
            return o.onload = function () {
                e.encodePacket({ type: t.type, data: o.result }, n, !0, r);
            }, o.readAsArrayBuffer(t.data);
        }

        function s(t, n, r) {
            if (!n) return e.encodeBase64Packet(t, r);
            if (g) return i(t, n, r);
            var o = new Uint8Array(1);
            o[0] = v[t.type];
            var s = new k([o.buffer, t.data]);
            return r(s);
        }

        function a(t) {
            try {
                t = d.decode(t, { strict: !1 });
            } catch (e) {
                return !1;
            }
            return t;
        }

        function c(t, e, n) {
            for (var r = new Array(t.length), o = l(t.length, n), i = function i(t, n, o) {
                e(n, function (e, n) {
                    r[t] = n, o(e, r);
                });
            }, s = 0; s < t.length; s++) {
                i(s, t[s], o);
            }
        }

        var p,
            u = n(22),
            h = n(23),
            f = n(24),
            l = n(25),
            d = n(26);
        "undefined" != typeof ArrayBuffer && (p = n(27));
        var y = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent),
            m = "undefined" != typeof navigator && /PhantomJS/i.test(navigator.userAgent),
            g = y || m;
        e.protocol = 3;
        var v = e.packets = { open: 0, close: 1, ping: 2, pong: 3, message: 4, upgrade: 5, noop: 6 },
            b = u(v),
            w = { type: "error", data: "parser error" },
            k = n(28);
        e.encodePacket = function (t, e, n, i) {
            "function" == typeof e && (i = e, e = !1), "function" == typeof n && (i = n, n = null);
            var a = void 0 === t.data ? void 0 : t.data.buffer || t.data;
            if ("undefined" != typeof ArrayBuffer && a instanceof ArrayBuffer) return o(t, e, i);
            if ("undefined" != typeof k && a instanceof k) return s(t, e, i);
            if (a && a.base64) return r(t, i);
            var c = v[t.type];
            return void 0 !== t.data && (c += n ? d.encode(String(t.data), { strict: !1 }) : String(t.data)), i("" + c);
        }, e.encodeBase64Packet = function (t, n) {
            var r = "b" + e.packets[t.type];
            if ("undefined" != typeof k && t.data instanceof k) {
                var o = new FileReader();
                return o.onload = function () {
                    var t = o.result.split(",")[1];
                    n(r + t);
                }, o.readAsDataURL(t.data);
            }
            var i;
            try {
                i = String.fromCharCode.apply(null, new Uint8Array(t.data));
            } catch (s) {
                for (var a = new Uint8Array(t.data), c = new Array(a.length), p = 0; p < a.length; p++) {
                    c[p] = a[p];
                }i = String.fromCharCode.apply(null, c);
            }
            return r += btoa(i), n(r);
        }, e.decodePacket = function (t, n, r) {
            if (void 0 === t) return w;
            if ("string" == typeof t) {
                if ("b" === t.charAt(0)) return e.decodeBase64Packet(t.substr(1), n);
                if (r && (t = a(t), t === !1)) return w;
                var o = t.charAt(0);
                return Number(o) == o && b[o] ? t.length > 1 ? { type: b[o], data: t.substring(1) } : { type: b[o] } : w;
            }
            var i = new Uint8Array(t),
                o = i[0],
                s = f(t, 1);
            return k && "blob" === n && (s = new k([s])), { type: b[o], data: s };
        }, e.decodeBase64Packet = function (t, e) {
            var n = b[t.charAt(0)];
            if (!p) return { type: n, data: { base64: !0, data: t.substr(1) } };
            var r = p.decode(t.substr(1));
            return "blob" === e && k && (r = new k([r])), { type: n, data: r };
        }, e.encodePayload = function (t, n, r) {
            function o(t) {
                return t.length + ":" + t;
            }

            function i(t, r) {
                e.encodePacket(t, !!s && n, !1, function (t) {
                    r(null, o(t));
                });
            }

            "function" == typeof n && (r = n, n = null);
            var s = h(t);
            return n && s ? k && !g ? e.encodePayloadAsBlob(t, r) : e.encodePayloadAsArrayBuffer(t, r) : t.length ? void c(t, i, function (t, e) {
                return r(e.join(""));
            }) : r("0:");
        }, e.decodePayload = function (t, n, r) {
            if ("string" != typeof t) return e.decodePayloadAsBinary(t, n, r);
            "function" == typeof n && (r = n, n = null);
            var o;
            if ("" === t) return r(w, 0, 1);
            for (var i, s, a = "", c = 0, p = t.length; c < p; c++) {
                var u = t.charAt(c);
                if (":" === u) {
                    if ("" === a || a != (i = Number(a))) return r(w, 0, 1);
                    if (s = t.substr(c + 1, i), a != s.length) return r(w, 0, 1);
                    if (s.length) {
                        if (o = e.decodePacket(s, n, !1), w.type === o.type && w.data === o.data) return r(w, 0, 1);
                        var h = r(o, c + i, p);
                        if (!1 === h) return;
                    }
                    c += i, a = "";
                } else a += u;
            }
            return "" !== a ? r(w, 0, 1) : void 0;
        }, e.encodePayloadAsArrayBuffer = function (t, n) {
            function r(t, n) {
                e.encodePacket(t, !0, !0, function (t) {
                    return n(null, t);
                });
            }

            return t.length ? void c(t, r, function (t, e) {
                var r = e.reduce(function (t, e) {
                    var n;
                    return n = "string" == typeof e ? e.length : e.byteLength, t + n.toString().length + n + 2;
                }, 0),
                    o = new Uint8Array(r),
                    i = 0;
                return e.forEach(function (t) {
                    var e = "string" == typeof t,
                        n = t;
                    if (e) {
                        for (var r = new Uint8Array(t.length), s = 0; s < t.length; s++) {
                            r[s] = t.charCodeAt(s);
                        }n = r.buffer;
                    }
                    e ? o[i++] = 0 : o[i++] = 1;
                    for (var a = n.byteLength.toString(), s = 0; s < a.length; s++) {
                        o[i++] = parseInt(a[s]);
                    }o[i++] = 255;
                    for (var r = new Uint8Array(n), s = 0; s < r.length; s++) {
                        o[i++] = r[s];
                    }
                }), n(o.buffer);
            }) : n(new ArrayBuffer(0));
        }, e.encodePayloadAsBlob = function (t, n) {
            function r(t, n) {
                e.encodePacket(t, !0, !0, function (t) {
                    var e = new Uint8Array(1);
                    if (e[0] = 1, "string" == typeof t) {
                        for (var r = new Uint8Array(t.length), o = 0; o < t.length; o++) {
                            r[o] = t.charCodeAt(o);
                        }t = r.buffer, e[0] = 0;
                    }
                    for (var i = t instanceof ArrayBuffer ? t.byteLength : t.size, s = i.toString(), a = new Uint8Array(s.length + 1), o = 0; o < s.length; o++) {
                        a[o] = parseInt(s[o]);
                    }if (a[s.length] = 255, k) {
                        var c = new k([e.buffer, a.buffer, t]);
                        n(null, c);
                    }
                });
            }

            c(t, r, function (t, e) {
                return n(new k(e));
            });
        }, e.decodePayloadAsBinary = function (t, n, r) {
            "function" == typeof n && (r = n, n = null);
            for (var o = t, i = []; o.byteLength > 0;) {
                for (var s = new Uint8Array(o), a = 0 === s[0], c = "", p = 1; 255 !== s[p]; p++) {
                    if (c.length > 310) return r(w, 0, 1);
                    c += s[p];
                }
                o = f(o, 2 + c.length), c = parseInt(c);
                var u = f(o, 0, c);
                if (a) try {
                    u = String.fromCharCode.apply(null, new Uint8Array(u));
                } catch (h) {
                    var l = new Uint8Array(u);
                    u = "";
                    for (var p = 0; p < l.length; p++) {
                        u += String.fromCharCode(l[p]);
                    }
                }
                i.push(u), o = f(o, c);
            }
            var d = i.length;
            i.forEach(function (t, o) {
                r(e.decodePacket(t, n, !0), o, d);
            });
        };
    }, function (t, e) {
        t.exports = Object.keys || function (t) {
            var e = [],
                n = Object.prototype.hasOwnProperty;
            for (var r in t) {
                n.call(t, r) && e.push(r);
            }return e;
        };
    }, function (t, e, n) {
        function r(t) {
            if (!t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t))) return !1;
            if (o(t)) {
                for (var e = 0, n = t.length; e < n; e++) {
                    if (r(t[e])) return !0;
                }return !1;
            }
            if ("function" == typeof Buffer && Buffer.isBuffer && Buffer.isBuffer(t) || "function" == typeof ArrayBuffer && t instanceof ArrayBuffer || s && t instanceof Blob || a && t instanceof File) return !0;
            if (t.toJSON && "function" == typeof t.toJSON && 1 === arguments.length) return r(t.toJSON(), !0);
            for (var i in t) {
                if (Object.prototype.hasOwnProperty.call(t, i) && r(t[i])) return !0;
            }return !1;
        }

        var o = n(10),
            i = Object.prototype.toString,
            s = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === i.call(Blob),
            a = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === i.call(File);
        t.exports = r;
    }, function (t, e) {
        t.exports = function (t, e, n) {
            var r = t.byteLength;
            if (e = e || 0, n = n || r, t.slice) return t.slice(e, n);
            if (e < 0 && (e += r), n < 0 && (n += r), n > r && (n = r), e >= r || e >= n || 0 === r) return new ArrayBuffer(0);
            for (var o = new Uint8Array(t), i = new Uint8Array(n - e), s = e, a = 0; s < n; s++, a++) {
                i[a] = o[s];
            }return i.buffer;
        };
    }, function (t, e) {
        function n(t, e, n) {
            function o(t, r) {
                if (o.count <= 0) throw new Error("after called too many times");
                --o.count, t ? (i = !0, e(t), e = n) : 0 !== o.count || i || e(null, r);
            }

            var i = !1;
            return n = n || r, o.count = t, 0 === t ? e() : o;
        }

        function r() {}

        t.exports = n;
    }, function (t, e) {
        function n(t) {
            for (var e, n, r = [], o = 0, i = t.length; o < i;) {
                e = t.charCodeAt(o++), e >= 55296 && e <= 56319 && o < i ? (n = t.charCodeAt(o++), 56320 == (64512 & n) ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e), o--)) : r.push(e);
            }return r;
        }

        function r(t) {
            for (var e, n = t.length, r = -1, o = ""; ++r < n;) {
                e = t[r], e > 65535 && (e -= 65536, o += d(e >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), o += d(e);
            }return o;
        }

        function o(t, e) {
            if (t >= 55296 && t <= 57343) {
                if (e) throw Error("Lone surrogate U+" + t.toString(16).toUpperCase() + " is not a scalar value");
                return !1;
            }
            return !0;
        }

        function i(t, e) {
            return d(t >> e & 63 | 128);
        }

        function s(t, e) {
            if (0 == (4294967168 & t)) return d(t);
            var n = "";
            return 0 == (4294965248 & t) ? n = d(t >> 6 & 31 | 192) : 0 == (4294901760 & t) ? (o(t, e) || (t = 65533), n = d(t >> 12 & 15 | 224), n += i(t, 6)) : 0 == (4292870144 & t) && (n = d(t >> 18 & 7 | 240), n += i(t, 12), n += i(t, 6)), n += d(63 & t | 128);
        }

        function a(t, e) {
            e = e || {};
            for (var r, o = !1 !== e.strict, i = n(t), a = i.length, c = -1, p = ""; ++c < a;) {
                r = i[c], p += s(r, o);
            }return p;
        }

        function c() {
            if (l >= f) throw Error("Invalid byte index");
            var t = 255 & h[l];
            if (l++, 128 == (192 & t)) return 63 & t;
            throw Error("Invalid continuation byte");
        }

        function p(t) {
            var e, n, r, i, s;
            if (l > f) throw Error("Invalid byte index");
            if (l == f) return !1;
            if (e = 255 & h[l], l++, 0 == (128 & e)) return e;
            if (192 == (224 & e)) {
                if (n = c(), s = (31 & e) << 6 | n, s >= 128) return s;
                throw Error("Invalid continuation byte");
            }
            if (224 == (240 & e)) {
                if (n = c(), r = c(), s = (15 & e) << 12 | n << 6 | r, s >= 2048) return o(s, t) ? s : 65533;
                throw Error("Invalid continuation byte");
            }
            if (240 == (248 & e) && (n = c(), r = c(), i = c(), s = (7 & e) << 18 | n << 12 | r << 6 | i, s >= 65536 && s <= 1114111)) return s;
            throw Error("Invalid UTF-8 detected");
        }

        function u(t, e) {
            e = e || {};
            var o = !1 !== e.strict;
            h = n(t), f = h.length, l = 0;
            for (var i, s = []; (i = p(o)) !== !1;) {
                s.push(i);
            }return r(s);
        } /*! https://mths.be/utf8js v2.1.2 by @mathias */
        var h,
            f,
            l,
            d = String.fromCharCode;
        t.exports = { version: "2.1.2", encode: a, decode: u };
    }, function (t, e) {
        !function () {
            "use strict";

            for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(256), r = 0; r < t.length; r++) {
                n[t.charCodeAt(r)] = r;
            }e.encode = function (e) {
                var n,
                    r = new Uint8Array(e),
                    o = r.length,
                    i = "";
                for (n = 0; n < o; n += 3) {
                    i += t[r[n] >> 2], i += t[(3 & r[n]) << 4 | r[n + 1] >> 4], i += t[(15 & r[n + 1]) << 2 | r[n + 2] >> 6], i += t[63 & r[n + 2]];
                }return o % 3 === 2 ? i = i.substring(0, i.length - 1) + "=" : o % 3 === 1 && (i = i.substring(0, i.length - 2) + "=="), i;
            }, e.decode = function (t) {
                var e,
                    r,
                    o,
                    i,
                    s,
                    a = .75 * t.length,
                    c = t.length,
                    p = 0;
                "=" === t[t.length - 1] && (a--, "=" === t[t.length - 2] && a--);
                var u = new ArrayBuffer(a),
                    h = new Uint8Array(u);
                for (e = 0; e < c; e += 4) {
                    r = n[t.charCodeAt(e)], o = n[t.charCodeAt(e + 1)], i = n[t.charCodeAt(e + 2)], s = n[t.charCodeAt(e + 3)], h[p++] = r << 2 | o >> 4, h[p++] = (15 & o) << 4 | i >> 2, h[p++] = (3 & i) << 6 | 63 & s;
                }return u;
            };
        }();
    }, function (t, e) {
        function n(t) {
            return t.map(function (t) {
                if (t.buffer instanceof ArrayBuffer) {
                    var e = t.buffer;
                    if (t.byteLength !== e.byteLength) {
                        var n = new Uint8Array(t.byteLength);
                        n.set(new Uint8Array(e, t.byteOffset, t.byteLength)), e = n.buffer;
                    }
                    return e;
                }
                return t;
            });
        }

        function r(t, e) {
            e = e || {};
            var r = new i();
            return n(t).forEach(function (t) {
                r.append(t);
            }), e.type ? r.getBlob(e.type) : r.getBlob();
        }

        function o(t, e) {
            return new Blob(n(t), e || {});
        }

        var i = "undefined" != typeof i ? i : "undefined" != typeof WebKitBlobBuilder ? WebKitBlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder && MozBlobBuilder,
            s = function () {
            try {
                var t = new Blob(["hi"]);
                return 2 === t.size;
            } catch (e) {
                return !1;
            }
        }(),
            a = s && function () {
            try {
                var t = new Blob([new Uint8Array([1, 2])]);
                return 2 === t.size;
            } catch (e) {
                return !1;
            }
        }(),
            c = i && i.prototype.append && i.prototype.getBlob;
        "undefined" != typeof Blob && (r.prototype = Blob.prototype, o.prototype = Blob.prototype), t.exports = function () {
            return s ? a ? Blob : o : c ? r : void 0;
        }();
    }, function (t, e) {
        e.encode = function (t) {
            var e = "";
            for (var n in t) {
                t.hasOwnProperty(n) && (e.length && (e += "&"), e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n]));
            }return e;
        }, e.decode = function (t) {
            for (var e = {}, n = t.split("&"), r = 0, o = n.length; r < o; r++) {
                var i = n[r].split("=");
                e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);
            }
            return e;
        };
    }, function (t, e) {
        t.exports = function (t, e) {
            var n = function n() {};
            n.prototype = e.prototype, t.prototype = new n(), t.prototype.constructor = t;
        };
    }, function (t, e) {
        "use strict";

        function n(t) {
            var e = "";
            do {
                e = s[t % a] + e, t = Math.floor(t / a);
            } while (t > 0);
            return e;
        }

        function r(t) {
            var e = 0;
            for (u = 0; u < t.length; u++) {
                e = e * a + c[t.charAt(u)];
            }return e;
        }

        function o() {
            var t = n(+new Date());
            return t !== i ? (p = 0, i = t) : t + "." + n(p++);
        }

        for (var i, s = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), a = 64, c = {}, p = 0, u = 0; u < a; u++) {
            c[s[u]] = u;
        }o.encode = n, o.decode = r, t.exports = o;
    }, function (t, e, n) {
        (function (e) {
            function r() {}

            function o() {
                return "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof e ? e : {};
            }

            function i(t) {
                if (s.call(this, t), this.query = this.query || {}, !c) {
                    var e = o();
                    c = e.___eio = e.___eio || [];
                }
                this.index = c.length;
                var n = this;
                c.push(function (t) {
                    n.onData(t);
                }), this.query.j = this.index, "function" == typeof addEventListener && addEventListener("beforeunload", function () {
                    n.script && (n.script.onerror = r);
                }, !1);
            }

            var s = n(19),
                a = n(30);
            t.exports = i;
            var c,
                p = /\n/g,
                u = /\\n/g;
            a(i, s), i.prototype.supportsBinary = !1, i.prototype.doClose = function () {
                this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), s.prototype.doClose.call(this);
            }, i.prototype.doPoll = function () {
                var t = this,
                    e = document.createElement("script");
                this.script && (this.script.parentNode.removeChild(this.script), this.script = null), e.async = !0, e.src = this.uri(), e.onerror = function (e) {
                    t.onError("jsonp poll error", e);
                };
                var n = document.getElementsByTagName("script")[0];
                n ? n.parentNode.insertBefore(e, n) : (document.head || document.body).appendChild(e), this.script = e;
                var r = "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent);
                r && setTimeout(function () {
                    var t = document.createElement("iframe");
                    document.body.appendChild(t), document.body.removeChild(t);
                }, 100);
            }, i.prototype.doWrite = function (t, e) {
                function n() {
                    r(), e();
                }

                function r() {
                    if (o.iframe) try {
                        o.form.removeChild(o.iframe);
                    } catch (t) {
                        o.onError("jsonp polling iframe removal error", t);
                    }
                    try {
                        var e = '<iframe src="javascript:0" name="' + o.iframeId + '">';
                        i = document.createElement(e);
                    } catch (t) {
                        i = document.createElement("iframe"), i.name = o.iframeId, i.src = "javascript:0";
                    }
                    i.id = o.iframeId, o.form.appendChild(i), o.iframe = i;
                }

                var o = this;
                if (!this.form) {
                    var i,
                        s = document.createElement("form"),
                        a = document.createElement("textarea"),
                        c = this.iframeId = "eio_iframe_" + this.index;
                    s.className = "socketio", s.style.position = "absolute", s.style.top = "-1000px", s.style.left = "-1000px", s.target = c, s.method = "POST", s.setAttribute("accept-charset", "utf-8"), a.name = "d", s.appendChild(a), document.body.appendChild(s), this.form = s, this.area = a;
                }
                this.form.action = this.uri(), r(), t = t.replace(u, "\\\n"), this.area.value = t.replace(p, "\\n");
                try {
                    this.form.submit();
                } catch (h) {}
                this.iframe.attachEvent ? this.iframe.onreadystatechange = function () {
                    "complete" === o.iframe.readyState && n();
                } : this.iframe.onload = n;
            };
        }).call(e, function () {
            return this;
        }());
    }, function (t, e, n) {
        function r(t) {
            var e = t && t.forceBase64;
            e && (this.supportsBinary = !1), this.perMessageDeflate = t.perMessageDeflate, this.usingBrowserWebSocket = o && !t.forceNode, this.protocols = t.protocols, this.usingBrowserWebSocket || (l = i), s.call(this, t);
        }

        var o,
            i,
            s = n(20),
            a = n(21),
            c = n(29),
            p = n(30),
            u = n(31),
            h = n(3)("engine.io-client:websocket");
        if ("undefined" == typeof self) try {
            i = n(34);
        } catch (f) {} else o = self.WebSocket || self.MozWebSocket;
        var l = o || i;
        t.exports = r, p(r, s), r.prototype.name = "websocket", r.prototype.supportsBinary = !0, r.prototype.doOpen = function () {
            if (this.check()) {
                var t = this.uri(),
                    e = this.protocols,
                    n = { agent: this.agent, perMessageDeflate: this.perMessageDeflate };
                n.pfx = this.pfx, n.key = this.key, n.passphrase = this.passphrase, n.cert = this.cert, n.ca = this.ca, n.ciphers = this.ciphers, n.rejectUnauthorized = this.rejectUnauthorized, this.extraHeaders && (n.headers = this.extraHeaders), this.localAddress && (n.localAddress = this.localAddress);
                try {
                    this.ws = this.usingBrowserWebSocket && !this.isReactNative ? e ? new l(t, e) : new l(t) : new l(t, e, n);
                } catch (r) {
                    return this.emit("error", r);
                }
                void 0 === this.ws.binaryType && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners();
            }
        }, r.prototype.addEventListeners = function () {
            var t = this;
            this.ws.onopen = function () {
                t.onOpen();
            }, this.ws.onclose = function () {
                t.onClose();
            }, this.ws.onmessage = function (e) {
                t.onData(e.data);
            }, this.ws.onerror = function (e) {
                t.onError("websocket error", e);
            };
        }, r.prototype.write = function (t) {
            function e() {
                n.emit("flush"), setTimeout(function () {
                    n.writable = !0, n.emit("drain");
                }, 0);
            }

            var n = this;
            this.writable = !1;
            for (var r = t.length, o = 0, i = r; o < i; o++) {
                !function (t) {
                    a.encodePacket(t, n.supportsBinary, function (o) {
                        if (!n.usingBrowserWebSocket) {
                            var i = {};
                            if (t.options && (i.compress = t.options.compress), n.perMessageDeflate) {
                                var s = "string" == typeof o ? Buffer.byteLength(o) : o.length;
                                s < n.perMessageDeflate.threshold && (i.compress = !1);
                            }
                        }
                        try {
                            n.usingBrowserWebSocket ? n.ws.send(o) : n.ws.send(o, i);
                        } catch (a) {
                            h("websocket closed before onclose event");
                        }
                        --r || e();
                    });
                }(t[o]);
            }
        }, r.prototype.onClose = function () {
            s.prototype.onClose.call(this);
        }, r.prototype.doClose = function () {
            "undefined" != typeof this.ws && this.ws.close();
        }, r.prototype.uri = function () {
            var t = this.query || {},
                e = this.secure ? "wss" : "ws",
                n = "";
            this.port && ("wss" === e && 443 !== Number(this.port) || "ws" === e && 80 !== Number(this.port)) && (n = ":" + this.port), this.timestampRequests && (t[this.timestampParam] = u()), this.supportsBinary || (t.b64 = 1), t = c.encode(t), t.length && (t = "?" + t);
            var r = this.hostname.indexOf(":") !== -1;
            return e + "://" + (r ? "[" + this.hostname + "]" : this.hostname) + n + this.path + t;
        }, r.prototype.check = function () {
            return !(!l || "__initialize" in l && this.name === r.prototype.name);
        };
    }, function (t, e) {}, function (t, e) {
        var n = [].indexOf;
        t.exports = function (t, e) {
            if (n) return t.indexOf(e);
            for (var r = 0; r < t.length; ++r) {
                if (t[r] === e) return r;
            }return -1;
        };
    }, function (t, e, n) {
        "use strict";

        function r(t, e, n) {
            this.io = t, this.nsp = e, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.flags = {}, n && n.query && (this.query = n.query), this.io.autoConnect && this.open();
        }

        var o = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
            return typeof t === "undefined" ? "undefined" : _typeof(t);
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t === "undefined" ? "undefined" : _typeof(t);
        },
            i = n(7),
            s = n(8),
            a = n(37),
            c = n(38),
            p = n(39),
            u = n(3)("socket.io-client:socket"),
            h = n(29),
            f = n(23);
        t.exports = e = r;
        var l = {
            connect: 1,
            connect_error: 1,
            connect_timeout: 1,
            connecting: 1,
            disconnect: 1,
            error: 1,
            reconnect: 1,
            reconnect_attempt: 1,
            reconnect_failed: 1,
            reconnect_error: 1,
            reconnecting: 1,
            ping: 1,
            pong: 1
        },
            d = s.prototype.emit;
        s(r.prototype), r.prototype.subEvents = function () {
            if (!this.subs) {
                var t = this.io;
                this.subs = [c(t, "open", p(this, "onopen")), c(t, "packet", p(this, "onpacket")), c(t, "close", p(this, "onclose"))];
            }
        }, r.prototype.open = r.prototype.connect = function () {
            return this.connected ? this : (this.subEvents(), this.io.open(), "open" === this.io.readyState && this.onopen(), this.emit("connecting"), this);
        }, r.prototype.send = function () {
            var t = a(arguments);
            return t.unshift("message"), this.emit.apply(this, t), this;
        }, r.prototype.emit = function (t) {
            if (l.hasOwnProperty(t)) return d.apply(this, arguments), this;
            var e = a(arguments),
                n = {
                type: (void 0 !== this.flags.binary ? this.flags.binary : f(e)) ? i.BINARY_EVENT : i.EVENT,
                data: e
            };
            return n.options = {}, n.options.compress = !this.flags || !1 !== this.flags.compress, "function" == typeof e[e.length - 1] && (u("emitting packet with ack id %d", this.ids), this.acks[this.ids] = e.pop(), n.id = this.ids++), this.connected ? this.packet(n) : this.sendBuffer.push(n), this.flags = {}, this;
        }, r.prototype.packet = function (t) {
            t.nsp = this.nsp, this.io.packet(t);
        }, r.prototype.onopen = function () {
            if (u("transport is open - connecting"), "/" !== this.nsp) if (this.query) {
                var t = "object" === o(this.query) ? h.encode(this.query) : this.query;
                u("sending connect packet with query %s", t), this.packet({ type: i.CONNECT, query: t });
            } else this.packet({ type: i.CONNECT });
        }, r.prototype.onclose = function (t) {
            u("close (%s)", t), this.connected = !1, this.disconnected = !0, delete this.id, this.emit("disconnect", t);
        }, r.prototype.onpacket = function (t) {
            var e = t.nsp === this.nsp,
                n = t.type === i.ERROR && "/" === t.nsp;
            if (e || n) switch (t.type) {
                case i.CONNECT:
                    this.onconnect();
                    break;
                case i.EVENT:
                    this.onevent(t);
                    break;
                case i.BINARY_EVENT:
                    this.onevent(t);
                    break;
                case i.ACK:
                    this.onack(t);
                    break;
                case i.BINARY_ACK:
                    this.onack(t);
                    break;
                case i.DISCONNECT:
                    this.ondisconnect();
                    break;
                case i.ERROR:
                    this.emit("error", t.data);
            }
        }, r.prototype.onevent = function (t) {
            var e = t.data || [];
            u("emitting event %j", e), null != t.id && (u("attaching ack callback to event"), e.push(this.ack(t.id))), this.connected ? d.apply(this, e) : this.receiveBuffer.push(e);
        }, r.prototype.ack = function (t) {
            var e = this,
                n = !1;
            return function () {
                if (!n) {
                    n = !0;
                    var r = a(arguments);
                    u("sending ack %j", r), e.packet({ type: f(r) ? i.BINARY_ACK : i.ACK, id: t, data: r });
                }
            };
        }, r.prototype.onack = function (t) {
            var e = this.acks[t.id];
            "function" == typeof e ? (u("calling ack %s with %j", t.id, t.data), e.apply(this, t.data), delete this.acks[t.id]) : u("bad ack %s", t.id);
        }, r.prototype.onconnect = function () {
            this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered();
        }, r.prototype.emitBuffered = function () {
            var t;
            for (t = 0; t < this.receiveBuffer.length; t++) {
                d.apply(this, this.receiveBuffer[t]);
            }for (this.receiveBuffer = [], t = 0; t < this.sendBuffer.length; t++) {
                this.packet(this.sendBuffer[t]);
            }this.sendBuffer = [];
        }, r.prototype.ondisconnect = function () {
            u("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect");
        }, r.prototype.destroy = function () {
            if (this.subs) {
                for (var t = 0; t < this.subs.length; t++) {
                    this.subs[t].destroy();
                }this.subs = null;
            }
            this.io.destroy(this);
        }, r.prototype.close = r.prototype.disconnect = function () {
            return this.connected && (u("performing disconnect (%s)", this.nsp), this.packet({ type: i.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
        }, r.prototype.compress = function (t) {
            return this.flags.compress = t, this;
        }, r.prototype.binary = function (t) {
            return this.flags.binary = t, this;
        };
    }, function (t, e) {
        function n(t, e) {
            var n = [];
            e = e || 0;
            for (var r = e || 0; r < t.length; r++) {
                n[r - e] = t[r];
            }return n;
        }

        t.exports = n;
    }, function (t, e) {
        "use strict";

        function n(t, e, n) {
            return t.on(e, n), {
                destroy: function destroy() {
                    t.removeListener(e, n);
                }
            };
        }

        t.exports = n;
    }, function (t, e) {
        var n = [].slice;
        t.exports = function (t, e) {
            if ("string" == typeof e && (e = t[e]), "function" != typeof e) throw new Error("bind() requires a function");
            var r = n.call(arguments, 2);
            return function () {
                return e.apply(t, r.concat(n.call(arguments)));
            };
        };
    }, function (t, e) {
        function n(t) {
            t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0;
        }

        t.exports = n, n.prototype.duration = function () {
            var t = this.ms * Math.pow(this.factor, this.attempts++);
            if (this.jitter) {
                var e = Math.random(),
                    n = Math.floor(e * this.jitter * t);
                t = 0 == (1 & Math.floor(10 * e)) ? t - n : t + n;
            }
            return 0 | Math.min(t, this.max);
        }, n.prototype.reset = function () {
            this.attempts = 0;
        }, n.prototype.setMin = function (t) {
            this.ms = t;
        }, n.prototype.setMax = function (t) {
            this.max = t;
        }, n.prototype.setJitter = function (t) {
            this.jitter = t;
        };
    }]);
});

}).call(this,require("buffer").Buffer)
},{"buffer":33}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
//import $ from './jquery-2.0.3.min'
var frag = document.createDocumentFragment();

var arrow = document.createElement('div'),
    button = document.createElement('button'),
    message = document.createElement('div'),
    moveMessage = document.createElement('div'),
    endMessage = document.createElement("div");

button.id = 'play-button';
message.id = 'game-message';
arrow.innerHTML = "&larr;";
arrow.id = 'pass-arrow';
endMessage.id = "end-message";
moveMessage.className = 'msgMove';
frag.appendChild(arrow);
frag.appendChild(button);
frag.appendChild(message);
frag.appendChild(endMessage);
frag.appendChild(moveMessage);

function moveMess() {
    var jdim = $(".msgMove");
    jdim.removeClass('anim');
    void moveMessage.offsetWidth;
    jdim.addClass('anim');
}

exports.default = {
    fragmentToDom: function fragmentToDom(dom) {
        dom.appendChild(frag);
        frag = null;
    },
    clearEvents: function clearEvents() {
        $(button).off("click");
        $(arrow).off("click");
    },
    showArrow: function showArrow() {
        arrow.classList.add('show');
    },
    hideArrow: function hideArrow() {
        arrow.classList.remove('show');
    },
    showButton: function showButton(text) {
        button.innerHTML = text;
        button.classList.add('show');
    },
    hideButton: function hideButton(text) {
        button.classList.remove('show');
    },
    arrowClickOnce: function arrowClickOnce(cb) {
        $(arrow).on("click", function () {
            cb();
            $(this).off("click");
        });
    },
    buttonClickOnce: function buttonClickOnce(cb) {
        $(button).on("click", function () {
            cb();
            $(this).off("click");
        });
    },
    showWin: function showWin(won) {
        endMessage.innerHTML = won ? "YOU WON!" : "YOU LOST!";
        endMessage.classList.add("show");
    },
    hideWin: function hideWin() {
        endMessage.classList.remove("show");
    },
    showMessage: function showMessage(msg) {
        message.innerHTML = msg;
        message.style.display = 'block';
    },
    showMoveMess: function showMoveMess(msg) {
        moveMessage.innerHTML = msg;
        moveMess();
    },
    showPassingScreen: function showPassingScreen(dir) {
        var directions = ['left', 'right', 'opposite'];
        this.showMessage("Pass three cards to the " + directions[dir]);
        [function () {
            $(arrow).css("transform", 'rotate(0)');
        }, function () {
            $(arrow).css("transform", 'rotate(180deg)');
        }, function () {
            $(arrow).css("transform", 'rotate(90deg)');
        }][dir]();
    },
    hideMessage: function hideMessage() {
        message.style.display = '';
    }
};

},{}],32:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],33:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":32,"buffer":33,"ieee754":34}],34:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}]},{},[23]);

//# sourceMappingURL=index.min.js.map
